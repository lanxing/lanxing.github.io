<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[在Docker环境下部署Kafka]]></title>
      <url>/2017/10/18/%E5%9C%A8Docker%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%83%A8%E7%BD%B2Kafka/</url>
      <content type="html"><![CDATA[<h3 id="1-下载kafka和zookeeper镜像"><a href="#1-下载kafka和zookeeper镜像" class="headerlink" title="1.下载kafka和zookeeper镜像"></a>1.下载kafka和zookeeper镜像</h3><ol>
<li><p>直接下载最新的zookeeper镜像，由于我已经下载过了，这里只做了更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull zookeeper</div></pre></td></tr></table></figure>
<p>​                        <img src="/2017/10/18/在Docker环境下部署Kafka/img1.png" alt="zookeeper镜像下载" title="zookeeper镜像下载"></p>
</li>
<li><p>下载kafka镜像，这里使用wurstmeister/kafka的最新镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull wurstmeister/kafka</div></pre></td></tr></table></figure>
<p>​                        <img src="/2017/10/18/在Docker环境下部署Kafka/img2.png" alt="kafka镜像下载" title="kafka镜像下载"></p>
</li>
</ol>
<p>下载完成后，运行docker images查看下载的镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure>
<p>​                            <img src="/2017/10/18/在Docker环境下部署Kafka/img3.png" alt="docker镜像" title="docker镜像"></p>
<h3 id="2-启动容器"><a href="#2-启动容器" class="headerlink" title="2.启动容器"></a>2.启动容器</h3><p>&emsp; &emsp; 由于要涉及到zookeeper和kafka之间的通信，所以我们运用docker内部容器通信机制先新建一个网络。</p>
<ol>
<li><p>新建网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network create app</div></pre></td></tr></table></figure>
<p>​                        <img src="/2017/10/18/在Docker环境下部署Kafka/img4.png" alt="新建docker网络" title="新建docker网络"></p>
<p>运行 docker network ls查看新建的网络</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network ls</div></pre></td></tr></table></figure>
<p>​                        <img src="/2017/10/18/在Docker环境下部署Kafka/img5.png" alt="查看新建网络" title="查看新建网络"></p>
<p>运行docker network inspect app查看网络详细信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker network inspect app</div></pre></td></tr></table></figure>
<p>​                        <img src="/2017/10/18/在Docker环境下部署Kafka/img6.png" alt="网络详细信息" title="网络详细信息"></p>
<p>从详细信息中可以看到其连接的containers为空，说明还没有容器连接进来</p>
</li>
<li><p>新建zookeeper和kafka容器</p>
<p>创建zookeeper容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --net=app --name zookeeper -p 2181 -t zookeeper</div></pre></td></tr></table></figure>
<p>创建kafka容器，注意由于使用的是docker创建的网络，所以KAFKA_ADVERTISED_HOST_NAME参数需要设置为0.0.0.0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">docker run --net=app --name kafka -p 9092 \</div><div class="line">--link zookeeper \</div><div class="line">--env KAFKA_ZOOKEEPER_CONNECT=zookeeper:2181 \</div><div class="line">--env KAFKA_ADVERTISED_HOST_NAME=0.0.0.0 \</div><div class="line">--env KAFKA_ADVERTISED_PORT=9092 \</div><div class="line">wurstmeister/kafka:latest</div></pre></td></tr></table></figure>
<p>运行docker ps查看正在运行的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker ps</div></pre></td></tr></table></figure>
<p>​                <img src="/2017/10/18/在Docker环境下部署Kafka/img7.png" alt="docker启动的容器" title="docker启动的容器"></p>
</li>
</ol>
<h3 id="3-测试发送消息和接受消息"><a href="#3-测试发送消息和接受消息" class="headerlink" title="3.测试发送消息和接受消息"></a>3.测试发送消息和接受消息</h3><p>在命令行下运行 docker exec -it kafka /bin/bash命令，进入kafka容器内部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exec -it kafka /bin/bash</div></pre></td></tr></table></figure>
<p>​                    <img src="/2017/10/18/在Docker环境下部署Kafka/img8.png" alt="kafka容器内部命令行" title="kafka容器内部命令行"></p>
<p>kafka文件存放在/opt/kafka_2.12-0.11.0.1/目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /opt/kafka_2.12-0.11.0.1/</div></pre></td></tr></table></figure>
<p>调用kafka-topics.sh创建一个mykafka的topic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-topics.sh --create --zookeeper zookeeper:2181 --replication-factor 1 --partitions 1 --topic mykafka</div></pre></td></tr></table></figure>
<p>调用kafka-console-producer.sh运行一个生产者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-producer.sh --broker-list localhost:9092 --topic mykafka</div></pre></td></tr></table></figure>
<p>​                    <img src="/2017/10/18/在Docker环境下部署Kafka/img9.png" alt="启动生产者" title="启动生产者"></p>
<p>启动另一个窗口，按照上边的步骤启动kafka容器的命令行，执行如下消费者命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-consumer.sh --zookeeper zookeeper:2181 --topic mykafka --from-beginning</div></pre></td></tr></table></figure>
<p>在生产者窗口发送一条命令，查看消费者端口是否接到命令</p>
<p>​                    <img src="/2017/10/18/在Docker环境下部署Kafka/img10.png" alt="发送消息" title="发送消息"></p>
<p>​                    <img src="/2017/10/18/在Docker环境下部署Kafka/img11.png" alt="接收消息" title="接收消息"></p>
]]></content>
      
        <categories>
            
            <category> Kafka </category>
            
        </categories>
        
        
        <tags>
            
            <tag> kafka </tag>
            
            <tag> docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty In Action(五-Buffers)]]></title>
      <url>/2017/09/28/Netty-In-Action-%E4%BA%94/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&emsp; &emsp; 当我们需要传输数据时，我们经常使用到Buffer。Java NIO实现了自己的Buffer类，但是功能相当有限并且效率低下。而JDK的ByteBuffer又相当笨重复杂。所以Netty实现了自己的ByteBuf来在pipeline中传输数据。</p>
<h3 id="Buffer-API"><a href="#Buffer-API" class="headerlink" title="Buffer API"></a>Buffer API</h3><p>&emsp; &emsp; Netty的buffer API包含两个接口：</p>
<ul>
<li>ByteBuf</li>
<li>ByteBufHolder</li>
</ul>
<p>&emsp; &emsp; Netty通过引用计数(reference-counting)的方式来标记什么时候需要释放一个buf及其包含的资源。Netty的Buffer有以下几个优势：</p>
<ul>
<li>如果有必要，可以自定义buffer类型</li>
<li>通过内置类型标识零拷贝</li>
<li>不需要调用flip()即可实现读写模式切换</li>
<li>读写index分离</li>
<li>提供链式方法</li>
<li>引用计数</li>
<li>提供池(Pooling)服务</li>
</ul>
<h3 id="ByteBuf-字节数据容器"><a href="#ByteBuf-字节数据容器" class="headerlink" title="ByteBuf-字节数据容器"></a>ByteBuf-字节数据容器</h3><p>&emsp; &emsp; ByteBuf主要用于字节缓存。ByteByf包含两个索引：读索引和写索引。这样我们可以通过调整读索引的位置来多次读取数据。</p>
<h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>&emsp; &emsp; 当我们向ByteBuf写数据时，写索引会增长写数据的字节数量。当我们读数据时，读索引也会增长。当读索引与写索引在同一个位置时说明数据已被读完。ByteBuf变为不可读状态，如果继续读就会抛出IndexOutOfBoundsException异常。</p>
<p>&emsp; &emsp; 当调用以“read”或“write”开头的方法时会增加读索引和写索引的位置。而调用“set”和“get”方法时则不会移动索引，但是会给出操作相对索引的位置。</p>
<p>&emsp; &emsp; ByteBuf存储字节数有最大值，当超过这个值时会抛出异常，目前这个最大值时Integer.MAX_VALUE。</p>
<p>​                <img src="/2017/09/28/Netty-In-Action-五/img1.png" alt="初始化readIndex和writeIndex置为0" title="初始化readIndex和writeIndex置为0"></p>
<h4 id="ByteBuf不同类型"><a href="#ByteBuf不同类型" class="headerlink" title="ByteBuf不同类型"></a>ByteBuf不同类型</h4><p>Netty提供三种不同类型的ByteBuf，我们可以根据需要选择不同的类型</p>
<ol>
<li><p>堆内存Buffer(HEAP BUFFERS)</p>
<p>&emsp; &emsp; 堆缓存是使用最广泛的，它将数据缓存在JVM的堆内存空间。Netty通过一个隐式数组来保存数据。如果我们没用池缓存(pool)技术，那么这种类型在分配和销毁内存时是非常快的.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ByteBuf heapBuf = ...;                  </div><div class="line">       <span class="keyword">if</span> (heapBuf.hasArray()) &#123;               <span class="comment">//1</span></div><div class="line">           <span class="keyword">byte</span>[] array = heapBuf.array();		<span class="comment">//2</span></div><div class="line">           <span class="keyword">int</span> offset = heapBuf.arrayOffset() + heapBuf.position();    <span class="comment">//3</span></div><div class="line">           <span class="keyword">int</span> length = heapBuf.readableBytes();       <span class="comment">//4</span></div><div class="line">           YourImpl.method(array, offset, length);     <span class="comment">//5</span></div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>//1 检测ByteBuf是否由数组支持(是否是HEAP BUFFER)</p>
<p>//2 获取数组引用</p>
<p>//3 计算数组第一个字节的偏移量</p>
<p>//4 计算可读的字节数</p>
<p>//5 自己业务逻辑实现</p>
<p>&emsp; &emsp; 通过非堆(noneheap)ByteBuf获取数组会抛UnsupportedOperationException异常，所以在使用数组时最好通过hasArray方法先进行检测。</p>
</li>
<li><p>直接内存Buffer(DIRECT BUFFERS)</p>
<p>&emsp; &emsp; 直接内存意味着Buffer处于堆外内存。当我们需要通过网络传输数据时直接内存会很方便。实际上，当我们没有使用直接内存时，在通过socket传输数据时JVM会拷贝一份Buffer中的数据，而直接内存则免去了这个步骤。但是直接内存的缺点是分配和销毁太过昂贵，这也是Netty使用Pool的原因。直接内存的另一个缺点是我们不能通过一个Array直接访问，当我们需要访问数据时需要获取数据的一份拷贝。</p>
<p>下面代码示例了如何访问直接内存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ByteBuf directBuf = ...;</div><div class="line">        <span class="keyword">if</span> (!directBuf.hasArray()) &#123;                                             <span class="comment">//1</span></div><div class="line">            <span class="keyword">int</span> length = directBuf.readableBytes();                              <span class="comment">//2</span></div><div class="line">            <span class="keyword">byte</span>[] array = <span class="keyword">new</span> <span class="keyword">byte</span>[length];                                     <span class="comment">//3</span></div><div class="line">            directBuf.getBytes(array);                                           <span class="comment">//4</span></div><div class="line">            YourImpl.method(array, <span class="number">0</span>, array.length);                             <span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>// 1判断byffer是否由数组支持(否表示直接内存)</p>
<p>//2 获取可读数据长度len</p>
<p>//3 分配一个容量为len的数组</p>
<p>//4 将数据督导数组中</p>
<p>//5 处理数据</p>
</li>
<li><p>复合Buffer(COMPOSITE BUFFER)</p>
<p>&emsp; &emsp; 复合缓冲区可以构造多个ByteBuf实例，并且提供一份组合视图。Netty提供了ByteBuf的子类CompositeByteBuf来处理复合缓冲区，CompositeByteBuf只是一个视图。CompositeByteBuf.hasArray永远返回false，因为她有可能包含堆缓存也可能包含直接内存缓存。</p>
<p>&emsp; &emsp; 例如一条信息可能由两部分组成：header和body，在一个应用中body可能相同而header不同，因此我们可以复用body而只改变header即可。</p>
<p>​                <img src="/2017/09/28/Netty-In-Action-五/img2.png" alt="CompositeByteBuf" title="CompositeByteBuf"></p>
<p>&emsp; &emsp; 而使用JDK的ByteBuffer很难这样实现，除非我们再构建一个数组来存储header和body，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Use an array to composite them</span></div><div class="line">      ByteBuffer[] message = <span class="keyword">new</span> ByteBuffer[] &#123; header, body &#125;;</div><div class="line">      <span class="comment">// Use copy to merge both</span></div><div class="line">      ByteBuffer message2 = ByteBuffer.allocate(</div><div class="line">              header.remaining()+ body.remaining();</div><div class="line">      message2.put(header);</div><div class="line">      message2.put(body);</div><div class="line">      message2.flip();</div></pre></td></tr></table></figure>
<p>下列代码是通过CompositeByteBuf的改进版本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CompositeByteBuf compBuf = ...;</div><div class="line">        ByteBuf heapBuf = ...;</div><div class="line">        ByteBuf directBuf = ...;</div><div class="line">        compBuf.addComponent(heapBuf, directBuf);                                <span class="comment">//1</span></div><div class="line">        .....</div><div class="line">        compBuf.removeComponent(<span class="number">0</span>);                                              <span class="comment">//2</span></div><div class="line">        <span class="keyword">for</span> (ByteBuf buf: compBuf) &#123;                                             <span class="comment">//3</span></div><div class="line">            System.out.println(buf.toString());</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>//1 将heapBuf和directBuf添加到复合缓冲Buffer中</p>
<p>//2 移除第一个ButeBuf(heapBuf)</p>
<p>//3 循环处理复合缓冲Buffer中的ByteBuf</p>
</li>
</ol>
<h3 id="ByteBuf字节级别的操作"><a href="#ByteBuf字节级别的操作" class="headerlink" title="ByteBuf字节级别的操作"></a>ByteBuf字节级别的操作</h3><p>&emsp; &emsp; ByteBuf提供了很多读写操作，并且比JDK的ByteBuffer更加简单易用且性能更好</p>
<h4 id="随机访问索引"><a href="#随机访问索引" class="headerlink" title="随机访问索引"></a>随机访问索引</h4><p>&emsp; &emsp; ByteBuf使用以0起始的索引，这意味着ByteBuf的第一个字节索引是0最后一个字节索引是capacity-1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ByteBuf buffer = ...;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.capacity(); i ++) &#123;</div><div class="line">        <span class="keyword">byte</span> b = buffer.getByte(i);</div><div class="line">        System.out.println((<span class="keyword">char</span>) b);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; 需要注意的是根据index访问数据并不会增加读索引和写索引的值。如果有需要可以通过readIndex(index)和write(index)来增加其索引值。</p>
<h4 id="顺序访问索引"><a href="#顺序访问索引" class="headerlink" title="顺序访问索引"></a>顺序访问索引</h4><p>&emsp; &emsp; ByteBuf通过readIndex来提供顺序读数据，通过writeIndex提供顺序写数据。与jdk的ByteBuffer不同的是我们不需要调用flip()来切换读写模式。如下图所示ByteBuf通过两个指针切分成三个区域。</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img3.png" alt="ByteBuf分割区域" title="ByteBuf分割区域"></p>
<p>//1 已读数据(可以被回收)</p>
<p>//2 未读数据</p>
<p>//3 可写数据</p>
<h4 id="可被回收的字节"><a href="#可被回收的字节" class="headerlink" title="可被回收的字节"></a>可被回收的字节</h4><p>&emsp; &emsp; 可以被回收的字节区域表示ByteBuf已经执行读操作所以可以被回收。初始化时，这段区域大小为0，当执行读操作时这个区域大小增加。需要注意的是只有执行”read”操作时才会增加该区域大小，”get”操作不会移动readerIndex。可以通过调用discardReadBytes()函数来回收该区域。</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img4.png" alt="discardReadBytes后区域图" title="discardReadBytes后区域图"></p>
<p>&emsp; &emsp; 当调用discardReadBytes()后，可被回收的区域大小为0，readerIndex为0。因为discardReadBytes()方法会执行内存复制操作将可读的数据复制到起始位置，所以我们最好不要频繁地调用该函数。</p>
<h4 id="可读字节-ByteBuf中实际内容"><a href="#可读字节-ByteBuf中实际内容" class="headerlink" title="可读字节(ByteBuf中实际内容)"></a>可读字节(ByteBuf中实际内容)</h4><p>&emsp; &emsp; 任何以”read”或者”skip”开头的操作都会增长readerIndex。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Iterates the readable bytes of a buffer.</span></div><div class="line">    ByteBuf buffer = ...;</div><div class="line">    <span class="keyword">while</span> (buffer.readable()) &#123;</div><div class="line">        System.out.println(buffer.readByte());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="可写字节"><a href="#可写字节" class="headerlink" title="可写字节"></a>可写字节</h4><p>&emsp; &emsp; 任何以write开头的操作都会增加wirerIndex的值。如果没有更多写空间，操作会抛出IndexOutOfBoundException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Fills the writable bytes of a buffer with random integers.</span></div><div class="line">    ByteBuf buffer = ...;</div><div class="line">    <span class="keyword">while</span> (buffer.writableBytes() &gt;= <span class="number">4</span>) &#123;</div><div class="line">        buffer.writeInt(random.nextInt());</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h4 id="清除索引"><a href="#清除索引" class="headerlink" title="清除索引"></a>清除索引</h4><p>&emsp; &emsp; 我们可以通过调用clear()函数来重置readerIndex和writerIndex。这个操作不会清除buffer内容，而是重置指针到0.</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img5.png" alt="调用clear后区域图" title="调用clear后区域图"></p>
<h4 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h4><p>&emsp; &emsp; indexOf()方法可以帮助我们定位一个值的索引位置。更加复杂的操作可以通过ByteBufProcessor实现。</p>
<h4 id="衍生缓冲区"><a href="#衍生缓冲区" class="headerlink" title="衍生缓冲区"></a>衍生缓冲区</h4><p>&emsp; &emsp; 为了创建一个已存在buffer的视图，可以调用duplicate()，slice()，slice(int, int)，readOnly()或者order(ByteOrder)。衍生缓冲区拥有自己独立的writerIndex和ReaderIndex以及索引标志，但却共享内部存储的数据。</p>
<p>&emsp; &emsp; 如果不想共享数据的话，可以调用copy()或者copy(int, int)函数来实现。如下示例表示ByteBuf的slice是如何工作的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">      ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);     <span class="comment">//1</span></div><div class="line">      ByteBuf sliced = buf.slice(<span class="number">0</span>, <span class="number">14</span>);                           			 <span class="comment">//2</span></div><div class="line">      System.out.println(sliced.toString(utf8);                                <span class="comment">//3</span></div><div class="line">      buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'J'</span>);                                        		 <span class="comment">//4</span></div><div class="line">      <span class="keyword">assert</span> buf.get(<span class="number">0</span>) == sliced.get(<span class="number">0</span>);                                      <span class="comment">//5</span></div></pre></td></tr></table></figure>
<p>//1 创建一个ByteBuf</p>
<p>//2 通过slice创建一个索引从0到14的ByteBuf</p>
<p>//3 输出结果为”Netty in Action”</p>
<p>//4 更新索引为0的字节</p>
<p>//5 返回true，因为两个ByteBuf共享同一套数据</p>
<p>下列代码创建了ByteBuf的一份拷贝数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Charset utf8 = Charset.forName(&quot;UTF-8&quot;);</div><div class="line">        ByteBuf buf = Unpooled.copiedBuffer(&quot;Netty in Action rocks!&quot;, utf8);     //1</div><div class="line">        ByteBuf copy = buf.copy(0, 14);                                          //2</div><div class="line">        System.out.println(copy.toString(utf8);                                  //3</div><div class="line">        buf.setByte(0, (byte) &apos;J&apos;);                                              //4</div><div class="line">        assert buf.get(0) != copy.get(0);                                        //5</div></pre></td></tr></table></figure>
<p>//1 创建一个ByteBuf</p>
<p>//2 copy索引从0到14的数据</p>
<p>//3 输出”Netty in Action”</p>
<p>//4 更新Index=0的字节值</p>
<p>//5 不会失败，因为两个ByteBuf不共用底层是数据</p>
<h4 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h4><p>ByteBuf有两种读写操作</p>
<ul>
<li><p>get/set开头的操作需要传入一个给定的index</p>
</li>
<li><p>Read/write操作不但读取当前索引的数据，还会增加readerIndex和WriterIndex</p>
<p>​                <img src="/2017/09/28/Netty-In-Action-五/img6.png" alt="get操作" title="get操作"></p>
<p>​                <img src="/2017/09/28/Netty-In-Action-五/img7.png" alt="set操作" title="set操作"></p>
<p>set操作没有无符号操作</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">      ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);     <span class="comment">//1</span></div><div class="line">      System.out.println((<span class="keyword">char</span>) buf.getByte(<span class="number">0</span>));                               <span class="comment">//2</span></div><div class="line"><span class="comment">// 3 </span></div><div class="line">      <span class="keyword">int</span> readerIndex = buf.readerIndex();</div><div class="line">      <span class="keyword">int</span> writerIndex = buf.writerIndex();</div><div class="line">      buf.setByte(<span class="number">0</span>, (<span class="keyword">byte</span>) <span class="string">'B'</span>);                                              <span class="comment">//4</span></div><div class="line">      System.out.println((<span class="keyword">char</span>) buf.getByte(<span class="number">0</span>));                               <span class="comment">//5</span></div><div class="line"><span class="comment">//6 </span></div><div class="line">      <span class="keyword">assert</span> readerIndex = buf.readerIndex();</div><div class="line">      <span class="keyword">assert</span> writerIndex = buf.writerIndex();</div></pre></td></tr></table></figure>
<p>//1 创建ByteBuf</p>
<p>//2 输出首个字节”N”</p>
<p>//3 储存readerIndex和writerIndex</p>
<p>//4 更新index=0的字节为“B”</p>
<p>//5 应该输出更新后的”B”</p>
<p>//6 true，因为get和set操作并不会修改索引</p>
<p>下面看下read和write操作</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img7.png" alt="read操作" title="read操作"></p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img8.png" alt="write操作" title="write操作"></p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img9.png" alt="write操作" title="write操作"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Charset utf8 = Charset.forName(<span class="string">"UTF-8"</span>);</div><div class="line">      ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"Netty in Action rocks!"</span>, utf8);     <span class="comment">//1</span></div><div class="line">      System.out.println((<span class="keyword">char</span>) buf.readByte());                               <span class="comment">//2</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="keyword">int</span> readerIndex = buf.readerIndex();                                     <span class="comment">//3</span></div><div class="line">      <span class="keyword">int</span> writerIndex = buf.writerIndex();                                     </div><div class="line">      buf.writeByte( (<span class="keyword">byte</span>) <span class="string">'?'</span>);                                              <span class="comment">//4</span></div><div class="line">      <span class="keyword">assert</span> readerIndex = buf.readerIndex();                                  <span class="comment">//5</span></div><div class="line">      <span class="keyword">assert</span> writerIndex != buf.writerIndex();</div></pre></td></tr></table></figure>
<p>//1 创建ByteBuf</p>
<p>//2 打印第一个字节”N”</p>
<p>//3 存储目前的readerIndex和writeIndex</p>
<p>//4 写一个字节</p>
<p>//5 readerIndex不变，而writerIndex增加</p>
<h4 id="其他有用的操作"><a href="#其他有用的操作" class="headerlink" title="其他有用的操作"></a>其他有用的操作</h4><p>​                        <img src="/2017/09/28/Netty-In-Action-五/img10.png" alt="其他操作" title="其他操作"></p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img11.png" alt="其他操作" title="其他操作"></p>
<h3 id="ByteBufHolder"><a href="#ByteBufHolder" class="headerlink" title="ByteBufHolder"></a>ByteBufHolder</h3><p>&emsp; &emsp; 一般来说，我们在实际应用中除了存储字节数据外，还需要存储一些其他属性。例如Http返回值中，除了返回的数据还有状态，cookie等信息。这种情况，Netty提供了一个抽象接口ByteBufHolder。ByteBufHolder还支持Netty的高级功能，例如其存储的数据可以直接从缓存池中获取，如果需要还可以自动释放。ByteBufHolder仅提供了几个方法：</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img12.png" alt="ByteBufHolder提供的方法" title="ByteBufHolder提供的方法"></p>
<h4 id="ByteBufAllocator"><a href="#ByteBufAllocator" class="headerlink" title="ByteBufAllocator"></a>ByteBufAllocator</h4><p>&emsp; &emsp; 之前提过，Netty支持池类缓存ByteBuf。ByteBufAllocator正是为实现池类缓存而设计的，当然用户可以自由选择是否使用池缓存</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img13.png" alt="ByteBufAllocator提供的方法" title="ByteBufAllocator提供的方法"></p>
<p>&emsp; &emsp; ByteBufAllocator允许传入标识ByteBuf初始和最大容量的参数。并且ByteBuf是可以自动扩容的，直到扩容到允许的最大值。</p>
<p>&emsp; &emsp; 获取ByteBufAllocator的引用很简单，我们可以通过channel(一般来说，channel还可以保存另一个ByteBufAllocator)或者绑定到ChannelHandler的ChannelHandlerContext获取。如下代码所示为如何获取ByteBufAllocator引用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Channel channel = ...;</div><div class="line">        ByteBufAllocator allocator = channel.alloc();                            <span class="comment">//1</span></div><div class="line">   ....</div><div class="line">        ChannelHandlerContext ctx = ...;</div><div class="line">        ByteBufAllocator allocator2 = ctx.alloc();                               <span class="comment">//2</span></div><div class="line">   ...</div></pre></td></tr></table></figure>
<p>//1 从channel获取ByteBufAllocator</p>
<p>//2 从ChannelHandlerContext中获取ByteBufAllocator</p>
<p>&emsp; &emsp; Netty有两种不同的ByteBufAllocator实现方式，一种通过池子缓存ByteBuf的实例来减少分配和销毁ByteBuf实例的开销，同时尽量减少内存碎片的产生。另外一种不缓存ByteBuf，每次都返回一个新的ByteBuf实例。Netty默认使用PooledByteBufAllocator(带有池缓存)，当然可以通过修改ChannelConfig配置或者在启动服务器时指定另一种ByteBufAllocator来使用不使用池缓存的模式。</p>
<h4 id="Unpooled"><a href="#Unpooled" class="headerlink" title="Unpooled"></a>Unpooled</h4><p>&emsp; &emsp; 有时候我们无法获取ByteBufAllocator的实例来声明ByteBuf，对于这种情况，Netty提供了一个工具类Unpooled，该类包含一些静态方法来创建无池缓存的ByteBuf。</p>
<p>​                        <img src="/2017/09/28/Netty-In-Action-五/img14.png" alt="Unpooled提供的方法" title="Unpooled提供的方法"></p>
<p>当然Unpooled也可以在不使用Netty时用来获取ByteBuf</p>
<h4 id="ByteBufUtil"><a href="#ByteBufUtil" class="headerlink" title="ByteBufUtil"></a>ByteBufUtil</h4><p>&emsp; &emsp; ByteBufUtil同样也提供了一些静态方法，尤其在操作ByteBuf时相当有用。其中最有用的应当是hexdump()方法，其主要用于将ByteBuf的内容以十六进制数据输出。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty In Action(四)]]></title>
      <url>/2017/09/21/Netty-In-Action-%E5%9B%9B/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&emsp; &emsp; 网络应用程序的主要功能是传输数据，而数据传输的方式有多种，我们在实际应用中根据具体的需求来选择合适的方式。使用过Java网络库的人都知道，如果我们想将阻塞应用转变为非阻塞应用会非常困难，因为他们用的是两套完全不同的API。</p>
<p>&emsp; &emsp; 而Netty则提供了一套统一的网络API，如果我们想要改变网络传输方式，我们不需要修改大量的代码。这使得我们的工作效率大大提升。</p>
<h3 id="案例研究：改变传输方式"><a href="#案例研究：改变传输方式" class="headerlink" title="案例研究：改变传输方式"></a>案例研究：改变传输方式</h3><p>&emsp; &emsp; 为了说明数据时如何传输的，我们写一个简单的服务器程序，这个程序接受新的连接并向客户写一个“Hi”字符串。</p>
<h4 id="不使用Netty的IO-NIO"><a href="#不使用Netty的IO-NIO" class="headerlink" title="不使用Netty的IO/NIO"></a>不使用Netty的IO/NIO</h4><p>&emsp; &emsp; 首先我们先看下不使用Netty的阻塞IO程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainOioServer</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            <span class="keyword">final</span> ServerSocket socket = <span class="keyword">new</span> ServerSocket(port);              <span class="comment">//1</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    <span class="keyword">final</span> Socket clientSocket = socket.accept();             <span class="comment">//2</span></div><div class="line">                    System.out.println(<span class="string">"Accepted connection from "</span> +</div><div class="line">                            clientSocket);</div><div class="line">                    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;                              <span class="comment">//3</span></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            OutputStream out;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                out = clientSocket.getOutputStream();</div><div class="line">                                out.write(<span class="string">"Hi!\r\n"</span>.getBytes(Charset.forName(<span class="string">"UTF-8"</span>))); <span class="comment">//4 </span></div><div class="line">                                out.flush();</div><div class="line">                                clientSocket.close();                        <span class="comment">//5</span></div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    clientSocket.close();</div><div class="line">                                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                                    <span class="comment">// ignore on close</span></div><div class="line">                                &#125;</div><div class="line">                            &#125; &#125;</div><div class="line">                    &#125;).start();                                              <span class="comment">//6</span></div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>绑定服务器的端口</li>
<li>接受新的连接</li>
<li>创建新的线程处理连接</li>
<li>向客户端写消息</li>
<li>写完成后关闭连接</li>
<li>启动线程</li>
</ol>
<p>&emsp; &emsp; 这段程序可以很好的工作，但一旦我们发现阻塞IO扩展性比较差而不能满足我们的需求时，我们会发现将其修改为异步程序是多么的困难，因为两套API是完全不同的。我们只有另写一套，如下代码所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNioServer</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Listening for connections on port "</span> + port);</div><div class="line">            ServerSocketChannel serverChannel;</div><div class="line">            Selector selector;</div><div class="line">            serverChannel = ServerSocketChannel.open();</div><div class="line">            ServerSocket ss = serverChannel.socket();</div><div class="line">            InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">            ss.bind(address);                                                <span class="comment">//1</span></div><div class="line">            serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">            selector = Selector.open();                                     <span class="comment">//2</span></div><div class="line">            serverChannel.register(selector, SelectionKey.OP_ACCEPT);       <span class="comment">//3</span></div><div class="line">            <span class="keyword">final</span> ByteBuffer msg = ByteBuffer.wrap(<span class="string">"Hi!\r\n"</span>.getBytes());</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    selector.select();                                      <span class="comment">//4</span></div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                    ex.printStackTrace();</div><div class="line">                    <span class="comment">// handle in a proper way</span></div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                Set&lt;SelectedKey&gt; readyKeys = selector.selectedKeys();        <span class="comment">//5</span></div><div class="line">                Iterator&lt;SelectedKey&gt; iterator = readyKeys.iterator();</div><div class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                    SelectionKey key = iterator.next();</div><div class="line">                    iterator.remove();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;                            <span class="comment">//6</span></div><div class="line">                            ServerSocketChannel server = (ServerSocketChannel)</div><div class="line">                                    key.channel();</div><div class="line">                            SocketChannel  client = server.accept();</div><div class="line">                            System.out.println(<span class="string">"Accept connection from "</span> + client);</div><div class="line">                            client.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                            client.register(selector, SelectionKey.OP_WRITE | </div><div class="line">                                    SelectionKey.OP_READ, msg.duplicate());     <span class="comment">//7</span></div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (key.isWritable()) &#123;                                 <span class="comment">//8</span></div><div class="line">                            SocketChannel client = (SocketChannel) key.channel();</div><div class="line">                            ByteBuffer buffer = (ByteBuffer) key.attachment();</div><div class="line">                            <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</div><div class="line">                                <span class="keyword">if</span> (client.write(buffer) == <span class="number">0</span>) &#123;                <span class="comment">//9</span></div><div class="line">                                    <span class="keyword">break</span>;</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                            client.close();                                     <span class="comment">//10</span></div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                        key.cancel();</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            key.channel().close();</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException cex) &#123;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>绑定服务器端口</li>
<li>打开Selector处理Channel</li>
<li>将ServerChannel注册到Selector上，并监听新连接到来事件</li>
<li>阻塞等待可执行的事件</li>
<li>获取所有可执行事件的实例</li>
<li>检测该事件是否是新连接事件</li>
<li>接受新的连接并将其注册到Selector上，监听该连接的读写事件</li>
<li>检测该事件是否是可写事件</li>
<li>向客户端写数据。当网络饱和的情况下一次可能写不完，当网络可写时将剩余的数据写入</li>
<li>关闭连接</li>
</ol>
<p>&emsp; &emsp; 如上所示，新的程序和之前的完全不同，尽管他们的功能是一样的。下面我们看下使用Netty来转换传输方式。</p>
<h4 id="使用Netty的IO-NIO"><a href="#使用Netty的IO-NIO" class="headerlink" title="使用Netty的IO/NIO"></a>使用Netty的IO/NIO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyOioServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(</div><div class="line">                Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>, Charset.forName(<span class="string">"UTF-8"</span>)));</div><div class="line">        EventLoopGroup group = <span class="keyword">new</span> OioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();                   <span class="comment">//1</span></div><div class="line">            b.group(group)                                               <span class="comment">//2</span></div><div class="line">                    .channel(OioServerSocketChannel.class)</div><div class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</div><div class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="comment">//3</span></div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></div><div class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                            ch.pipeline().addLast(</div><div class="line">                                    <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123; <span class="comment">//4</span></div><div class="line"></div><div class="line">                                        <span class="meta">@Override</span></div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">                                                ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                                            ctx.write(buf.duplicate())</div><div class="line">                                                    .addListener(ChannelFutureListener.CLOSE);  <span class="comment">//5</span></div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            ChannelFuture f = b.bind().sync();                              <span class="comment">//6</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            group.shutdownGracefully().sync();                              <span class="comment">//7</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建ServerBootstrap</li>
<li>使用OioEventLoopGroup阻塞模式</li>
<li>指定ChannelInitializer</li>
<li>向Pipline中新增handler用来处理新的连接</li>
<li>向客户端写数据，并增加Listener监听器，一旦数据写完就关闭连接</li>
<li>绑定Server开始接受连接</li>
<li>释放所有资源</li>
</ol>
<p>&emsp; &emsp; 如果我们想要将其修改为非阻塞(NIO)网络应用，我们只需要修改少部分代码即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyNioServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">final</span> ByteBuf buf = Unpooled.unreleasableBuffer(</div><div class="line">                Unpooled.copiedBuffer(<span class="string">"Hi!\r\n"</span>, Charset.forName(<span class="string">"UTF-8"</span>)));</div><div class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();                   <span class="comment">//1</span></div><div class="line">            b.group(group)                                               <span class="comment">//2</span></div><div class="line">                    .channel(NioServerSocketChannel.class)</div><div class="line">                    .localAddress(<span class="keyword">new</span> InetSocketAddress(port))</div><div class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;    <span class="comment">//3</span></div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></div><div class="line"><span class="function">                                <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                            ch.pipeline().addLast(</div><div class="line">                                    <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123; <span class="comment">//4</span></div><div class="line"></div><div class="line">                                        <span class="meta">@Override</span></div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">                                                ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                                            ctx.write(buf.duplicate())</div><div class="line">                                                    .addListener(ChannelFutureListener.CLOSE);  <span class="comment">//5</span></div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            ChannelFuture f = b.bind().sync();                              <span class="comment">//6</span></div><div class="line">            f.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            group.shutdownGracefully().sync();                              <span class="comment">//7</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; 我们只需要将OioEventLoopGroup修改为NioEventLoopGroup并将OioServerSocketChannel修改为NioServerSocketChannel即可。</p>
<h3 id="传输API"><a href="#传输API" class="headerlink" title="传输API"></a>传输API</h3><p>&emsp; &emsp; 传输API的核心是Channel接口，所有的输出流操作都用到了传输API，如下图所示Channel接口的层次接口图:</p>
<p>​                        <img src="/2017/09/21/Netty-In-Action-四/img1.png" alt="Channel的层次结构图" title="Channel的层次结构图"></p>
<p>&emsp; &emsp; 如上图所示，每个Channel都会分配一个ChannelPipeline和ChannelConfig。ChannelConfig负责存储配置信息并允许在运行期间修改。传输有特殊的配置而仅仅实现了ChannelConfig接口。ChannelPipeline则持有所有用于处理输入(inbound)和输出(outboud)流的ChannelHandler。这些Handler使我们能够响应网络状态变化或者处理数据。</p>
<p>到目前为止，我们可以用ChannelHandler处理以下事情：</p>
<ul>
<li>将数据从一种类型转换为另一种类型</li>
<li>异常提醒</li>
<li>Channel激活/暂停提醒</li>
<li>Channel注册/注销EventLoop提醒</li>
<li>用户特性事件提醒</li>
</ul>
<p>&emsp; &emsp; 这些ChannelHandler在ChannelPipeline中像链条一样一个一个执行。如果我们使用过Servlet，我们会发现他们很相似。</p>
<blockquote>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p>ChannelPipeline使用了拦截过滤器模式，这意味着你可以加入不同的CHannelHandler并且拦截ChannelPipeline中的数据或事件。这个和Unix中的管道(pipes，pipes可以将不同的命令串起来)很相似</p>
</blockquote>
<p>&emsp; &emsp; 我们可以在程序运行期间修改ChannelPipeline，可以在任何需要时刻向其添加/移除ChannelHandler。这样我们就运用Netty构造高度灵活的应用程序。</p>
<p>&emsp; &emsp; 除了可以获得ChannelPipeline和ChannelConfig外，Channel本身还提供了很多方法，如下表列出了一些重要的方法。</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">eventLoop()</td>
<td style="text-align:center">返回该Channel注册的EventLoop</td>
</tr>
<tr>
<td style="text-align:center">popline()</td>
<td style="text-align:center">返回该Channel所在的ChannelPipeline</td>
</tr>
<tr>
<td style="text-align:center">isActive()</td>
<td style="text-align:center">判断该CHannel是否激活，也就是是否连接到另一端</td>
</tr>
<tr>
<td style="text-align:center">localAddress()</td>
<td style="text-align:center">返回本地绑定的SocketAddress</td>
</tr>
<tr>
<td style="text-align:center">remoteAddress()</td>
<td style="text-align:center">返回远端绑定的SocketAddress</td>
</tr>
<tr>
<td style="text-align:center">write()</td>
<td style="text-align:center">向另一端写数据。写的数据通过ChannelPipeline传输</td>
</tr>
</tbody>
</table>
<p>&emsp; &emsp; 为了向远端写数据，我们调用Channel的write()方法，如下面代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Channel channel = ...</div><div class="line">    ByteBuf buf = Unpooled.copiedBuffer(<span class="string">"your data"</span>, CharsetUtil.UTF_8);    <span class="comment">//1</span></div><div class="line">    ChannelFuture cf = channel.write(buf);                                  <span class="comment">//2</span></div><div class="line">    cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;                    		<span class="comment">//3</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;                                       <span class="comment">//4</span></div><div class="line">                System.out.println(“Write successful“);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.err.println(“Write error“);                          <span class="comment">//5</span></div><div class="line">                future.cause().printStacktrace();</div><div class="line">            &#125; &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<ol>
<li>创建ByteBuf用来存储需要写的数据</li>
<li>写数据</li>
<li>添加ChannelFutureListener监听数据是否写完</li>
<li>正常写完数据</li>
<li>写数据异常</li>
</ol>
<p>&emsp; &emsp; 需要注意的是Channel是线程安全的，也就是说其所有操作都是线程安全的。这样我们就可以存储一个Channel的引用然后在任何时刻都可以通过他向远端写数据。下面是Netty在多线程下写数据的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Channel channel = ...</div><div class="line">    <span class="keyword">final</span> ByteBuf buf = Unpooled.copiedBuffer(„your data“,</div><div class="line">            CharsetUtil.UTF_8);                                              <span class="comment">//1</span></div><div class="line">    Runnable writer = <span class="keyword">new</span> Runnable() &#123;                                       <span class="comment">//2</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            channel.write(buf.duplicate());</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    Executor executor = Executors.newChachedThreadPool();                    <span class="comment">//3</span></div><div class="line">            <span class="comment">// write in one thread</span></div><div class="line">            executor.execute(writer);                                         <span class="comment">//4</span></div><div class="line">            <span class="comment">// write in another thread</span></div><div class="line">            executor.execute(writer);                                          <span class="comment">//5</span></div><div class="line">            ...</div></pre></td></tr></table></figure>
<ol>
<li>创建ByteBuf用来存储需要写的数据</li>
<li>创建向Channel写数据的Runnable</li>
<li>获取线程执行器Executor</li>
<li>执行Runnable任务</li>
<li>在另一个线程中执行Runnable任务</li>
</ol>
<p>Channel可以保证按照我们传数据的顺序来写数据。</p>
<h3 id="Netty包含的Transport"><a href="#Netty包含的Transport" class="headerlink" title="Netty包含的Transport"></a>Netty包含的Transport</h3><p>&emsp; &emsp; Netty自带了一些我们可以使用的传输协议，尽管不全，但也足够我们使用了。如下表所示为Netty中包含的传输</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">所在包</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NIO</td>
<td style="text-align:center">io.netty.channel.socket.nio</td>
<td style="text-align:center">以java.nio.channels包为基础，同时使用了选择器方法(selector)</td>
</tr>
<tr>
<td style="text-align:center">OIO</td>
<td style="text-align:center">io.netty.channel.socket.oio</td>
<td style="text-align:center">以java.net包为基础，使用了阻塞IO流</td>
</tr>
<tr>
<td style="text-align:center">Local</td>
<td style="text-align:center">io.netty.channel.local</td>
<td style="text-align:center">在虚拟机之间通信</td>
</tr>
<tr>
<td style="text-align:center">Embedded</td>
<td style="text-align:center">io.netty.channel.embedded</td>
<td style="text-align:center">专门供测试ChannelHandler使用，可以在无网状态下运行ChannelHandler</td>
</tr>
</tbody>
</table>
<h4 id="NIO-非阻塞IO"><a href="#NIO-非阻塞IO" class="headerlink" title="NIO-非阻塞IO"></a>NIO-非阻塞IO</h4><p>&emsp; &emsp; NIO传输是目前使用最多的。它基于Selector模式提供了完全异步的IO操作。用户可以通过注册来立即获取chanel状态变化。Channel变化可以分为以下几种</p>
<ul>
<li>一个新的Channel准备好被接收(新的连接到来)</li>
<li>Channel建立连接成功</li>
<li>Channel接受到新的数据并且可读</li>
<li>CHannel可发送数据</li>
</ul>
<p>&emsp; &emsp; 程序会对这些状态变更的事件做出相应的处理然后重置他们以便下次变更到来时重新相应。这里会有一个线程对Channel进行检测其状态是否变更，如果变更了就将其归类。</p>
<p>SelectionKey中定义的可订阅事件如下：</p>
<ul>
<li>OP_ACCEPT：提醒有新连接到来，建立Channel</li>
<li>OP_CONNECT：提醒连接完成</li>
<li>OP_READ：Channel中数据可读</li>
<li>OP_WRITE：提醒Channel中可写数据。大部分情况下没问题，但是有些系统会出现网络堵塞问题，当远端消费数据的速度小于我们写数据的速度时会出现这种问题</li>
</ul>
<p>&emsp; &emsp; Netty的NIO传输内部使用了这种模型来接受和发送数据，外部封装成统一的API给用户使用，掩盖了内部所有的实现细节。下图为Netty内部流程图。</p>
<p>​                        <img src="/2017/09/21/Netty-In-Action-四/img2.png" alt="Selector逻辑流程图" title="Selector逻辑流程图"></p>
<ol>
<li>新建的Channel注册到Selector上</li>
<li>选择处理器的变化通知</li>
<li>已经注册过的Channel</li>
<li>Selector.select()方法会一直堵塞直到有Channel状态变化或者超时</li>
<li>检测是否有状态变化</li>
<li>处理所有发生状态变化的Channel</li>
<li>在同一个线程中处理其他任务</li>
</ol>
<p>&emsp; &emsp; 这种模式的传输方式在处理任务的时候比起来阻塞传输(OIO)传输多少会有点延迟，这是由于Selector工作模式引起的，因为其收到状态变更的消息通知需要一定得时间。但这仅仅是毫秒级的，我们可以通过增加网络宽带来减少延迟。</p>
<p>&emsp; &emsp; 目前NIO传输适用的一个重要功能是“零文件拷贝”(zero-file-copy)。这个特性可以让我们快速有效地将文件系统的数据传输到网络栈中而不需要将数据先从内存空间拷贝到用户空间。</p>
<p>&emsp; &emsp; 但是并不是所有的操作系统都支持这种特性，另外，这种特性不适用于传输加密/压缩的数据，要传输这样的数据必须先将其传输到用户空间进行加工处理。所以只有传输原始数据才能使用这种特性。Ftp或者Http服务器下载大文件时可以使用这个特性。</p>
<h4 id="OIO-Old-blocking-IO"><a href="#OIO-Old-blocking-IO" class="headerlink" title="OIO-Old blocking IO"></a>OIO-Old blocking IO</h4><p>&emsp; &emsp; 在传统的Java net中，我们为每一个socket分配一个线程处理任务。或者多个socket共享一个线程，但是当一个socket堵塞时间比较长时可能导致该线程共享的所有其他socket堵塞。</p>
<p>&emsp; &emsp; Netty的NIO和OIO使用的是同一套API。之所以能够实现一套统一的API，Netty利用了socket上的SO_TIMEOUT属性，如果socket上的操作在一定得时间内没有完成，将会跑出SocketTimeoutException，Netty捕获该异常然后继续执行工作。然后再下一次EventLoop中，继续尝试执行。这是唯一有效的办法，但问题是抛出SocketTimeoutException是需要消耗资源的，因为它要执行StrackTrace等操作。</p>
<p>​                        <img src="/2017/09/21/Netty-In-Action-四/img3.png" alt="OIO逻辑流程图" title="OIO逻辑流程图"></p>
<ol>
<li>线程分配socket</li>
<li>socket连接远端服务器</li>
<li>读可能阻塞的socket</li>
<li>读操作完成</li>
<li>读操作完成并且获得读的数据然后处理数据</li>
<li>执行该socket提交的其他任务</li>
<li>继续循环</li>
</ol>
<h4 id="Local-虚拟机内通信"><a href="#Local-虚拟机内通信" class="headerlink" title="Local-虚拟机内通信"></a>Local-虚拟机内通信</h4><p>&emsp; &emsp; Netty可以提供本机内通信的API，该API和前面提供的API相同，并且类似于NIO是异步的。Client可以通过SocketAddress连接到本机服务器(类似于连接远程服务器一样)。需要注意的是我们在使用时客户端和服务器必须同时开着。</p>
<h4 id="Embedded-transport"><a href="#Embedded-transport" class="headerlink" title="Embedded transport"></a>Embedded transport</h4><p>&emsp; &emsp; Embedded主要用于测试ChannelHandler或者嵌入其他的ChannelHandler当做帮助类使用。</p>
<h3 id="合理选择传输类型"><a href="#合理选择传输类型" class="headerlink" title="合理选择传输类型"></a>合理选择传输类型</h3><p>&emsp; &emsp; 在实际应用中，我们需要根据实际情况选择不同的传输方式，下表是不同的协议支持的传输方式：</p>
<p>​                    <img src="/2017/09/21/Netty-In-Action-四/img4.png" alt="OIO逻辑流程图" title="OIO逻辑流程图"></p>
<p>&emsp; &emsp; 下面让我们总结下传输类型的使用场景</p>
<ul>
<li><p>低并发连接：如果并发量较低，可以先使用OIO传输模式，因为是低并发，我们不需要担心分配线程的限制，并且资源也不是问题。这时我们可能会产生什么才是低并发场景的疑问，这个很难界定。但只要记住NIO传输类型可以支持万级以及十万级的并发量。所以任何低于一千的并发量都可以称作低并发。</p>
<p>这种情况下OIO运行的会很好，但有时NIO在低并发下也会很合适。当连接非常”活”跃时，OIO的上下文切换可能会比较耗时。</p>
</li>
<li><p>高并发连接：当应用连接比较多时就需要选择NIO传输方式。</p>
</li>
<li><p>低延迟：如果对实时性要求较高，首先使用OIO。但仍然需要权衡下，因为低延迟意味着要消耗更多的线程</p>
</li>
<li><p>阻塞代码：如果你正在改造老代码，而老代码是线程阻塞的。对Netty来说，将阻塞的IO修改为非阻塞的代价较大，或许只能重写代码。因此可以先将其转换为OIO，然后在需要的时候修改为NIO</p>
</li>
<li><p>本机内通信：利用Local实现本机内通信</p>
</li>
<li><p>测试ChannelHandler：利用Embedded可以进行ChannelHandler测试</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">程序需求</th>
<th style="text-align:center">推荐的传输类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">低并发</td>
<td style="text-align:center">OIO</td>
</tr>
<tr>
<td style="text-align:center">高并发</td>
<td style="text-align:center">NIO</td>
</tr>
<tr>
<td style="text-align:center">低延迟</td>
<td style="text-align:center">OIO</td>
</tr>
<tr>
<td style="text-align:center">阻塞代码改造</td>
<td style="text-align:center">OIO</td>
</tr>
<tr>
<td style="text-align:center">本机通信</td>
<td style="text-align:center">Local</td>
</tr>
<tr>
<td style="text-align:center">测试ChannelHandler</td>
<td style="text-align:center">Embedded</td>
</tr>
</tbody>
</table>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty In Action(三)]]></title>
      <url>/2017/09/19/Netty-In-Action-%E4%B8%89/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>&emsp; &emsp; 本章我们将着重介绍以下几个概念，不同的是我们不会分开介绍而是通过讲解他们是如何协同工作的来帮助我们在脑海中构造一张Netty工作机制的蓝图。</p>
<ul>
<li>Bootstrap or ServerBootstrap</li>
<li>EventLoop</li>
<li>EventLoopGroup</li>
<li>ChannelPipeline</li>
<li>Channel</li>
<li>Future or ChannelFuture</li>
<li>ChannelInitializer</li>
<li>ChannelHandler</li>
</ul>
<h3 id="Netty速成"><a href="#Netty速成" class="headerlink" title="Netty速成"></a>Netty速成</h3><p>&emsp; &emsp; Netty应用是通过Bootstrap进行启动的，Bootstrap使配置Netty属性变得更加简单方便。为了能够支持多种协议以及处理数据，Netty使用了Handler机制，Handler主要用于处理一个或者一组特定的事件，这些事件包括数据编码或处理数据过程中的异常捕获等。</p>
<p>&emsp; &emsp; 我们最常使用的一种Handler是直接实现ChannelInboundHandler接口，通过该Handler我们可以接受数据并对其进行处理。当我们的应用还需要响应客户端并提供一个response时，我们还需要从ChannelInboundHandler中将数据写回客户端。换句话说，我们应用的业务逻辑通常都是在ChannelInboundHandler中的。</p>
<p>&emsp; &emsp; 当使用Netty实现一个客户端或者服务器应用时，我们需要知道如何来处理接收到或者需要发送的数据。这时就需要不同的Handler来处理数据。Netty通过ChannelInitializer来配置Handler。ChannelInitializer的作用是将ChannelHandler添加到被称作ChannelPipeline的对象中。当我们发送或者接受数据时，这些handler就会对这些数据进行处理。其实ChannelInitializer本身也是一个ChannelHandler，只不过它在将其他handler加到ChannelPipeline之后就会从其上边将自己移除。</p>
<p>&emsp; &emsp; 所有的Netty应用都是基于ChannelPipeline，并且ChannelPipeline和EventLoop及EventLoopGroup密切相关</p>
<p>&emsp; &emsp; EventLoop的目的是为Channel处理IO事件，一个EventLoop可以为多个Channel处理事件，而一个EventLoopGroup可以包含多个EventLoop。</p>
<p>&emsp; &emsp; Channel代表一个网络连接或者一些能够执行IO操作的组件，因此Channel是被EventLoop管理的，后者是专门用来处理IO事件的。</p>
<p>&emsp; &emsp; 在Netty应用中的所有IO操作都是异步执行的，例如当我们连接服务器或者收发数据时都是异步的。由于我们没法立即获取执行的数据或者不知道执行的操作是否完成，所以我们需要延迟检测操作是否执行成功或者注册一个listener来监听操作执行的结果。Netty使用Future或者ChannelFutures机制来注册listener用来监听操作是否执行成功。</p>
<h3 id="Channels-Events-and-Input-Output-IO"><a href="#Channels-Events-and-Input-Output-IO" class="headerlink" title="Channels, Events and Input/Output (IO)"></a>Channels, Events and Input/Output (IO)</h3><p>&emsp; &emsp; Netty是一个非阻塞的，基于事件驱动的网络框架，也就是说Netty需要通过线程来处理IO事件。一提到多线程，我们首先想到的就是要保证我们写的代码线程安全，但实际上我们没有必要这么做，下图说明了Netty处理事件的机制。</p>
<p>​                        <img src="/2017/09/19/Netty-In-Action-三/img1.png" alt="img1.png" title=""></p>
<p>&emsp; &emsp; 由上图可知Netty中包含多个EventLoopGroup，而每个EventLoopGroup又包含多个EventLoop。实际上我们可以将EventLoop当做处理具体网络事件的线程。</p>
<blockquote>
<h4 id="EventLoop与Thread的关系"><a href="#EventLoop与Thread的关系" class="headerlink" title="EventLoop与Thread的关系"></a>EventLoop与Thread的关系</h4><p>EventLoop在整个生命周期中只能绑定到一个线程(a single Thread)上</p>
</blockquote>
<p>&emsp; &emsp; 当我们注册一个Channel时，Netty将该Channel绑定到一个EventLoop上，而EventLoop又被绑定到一个线程中，所以我们在执行IO操作时没有必要使用同步机制因为所有发生在该Channel上的IO操作都被同一个线程执行。</p>
<p>&emsp; &emsp; 为了能够更进一步解释上图关系，我们了解一下EventLoop与EventLoopGroup的类继承关系。</p>
<p>​                            <img src="/2017/09/19/Netty-In-Action-三/img2.png" alt="EventLoop与EventLoopGroup类关系图" title="EventLoop与EventLoopGroup类关系图"></p>
<p>&emsp; &emsp; 我们知道EventLoopGroup可以包含多个EventLoop，但实际上EventLoop与EventLoopGroup满足“is-a”关系，也就是说EventLoop本身也是一个EventLoopGroup，所以任何可以使用EventLoopGroup的地方都可以使用一个特定的EventLoop。</p>
<h3 id="Bootstrapping-What-and-Why"><a href="#Bootstrapping-What-and-Why" class="headerlink" title="Bootstrapping: What and Why"></a>Bootstrapping: What and Why</h3><p>&emsp; &emsp; 在Netty中Bootstrapping是用来配置Netty应用的。由上一章可知，Netty中包含两种类型的BootStrap，一种专门供客户端或者DatagramChannel使用(Bootsrap)，另一种专门供服务端使用(ServerBootstrap)。无论我们的应用使用何种协议，最终决定我们使用哪种Bootstrap的是我们是要创建一个客户端(Client)应用还是服务端(Server)应用。</p>
<p>如下表为BootStrap与ServerBootstrap对比</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Bootstrap</th>
<th style="text-align:center">ServerBootstrap</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">作用</td>
<td style="text-align:center">连接远程服务器</td>
<td style="text-align:center">绑定并监听本地端口</td>
</tr>
<tr>
<td style="text-align:center">EventLoopGroup个数</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
<p>&emsp; &emsp; 我们先看一下Bootstrap与ServerBootstrap的不同之处，第一个不同之处是ServerBootstrap需要绑定到一个端口并且监听客户端连接而Bootstrap主要用于客户端连接服务器。Bootstrap最常用的方法是connect()，但我们也可以调用bind()来绑定端口并用其返回的ChannelFuture中的Channel的connect()方法完成连接。</p>
<p>&emsp; &emsp; 第二个不同之处是比较重要的，Bootstrap只包含一个EventLoopGroup而ServerBootstrap则包含两个EventLoopGroup(两个EventLoopGroup可以使用同一个实例)。实际上ServerBootstrap中包含两种类型的channel。第一种只包含一个ServerChannel，这个ServerChannel是绑定到本地监听端口的一个socket。第二中包含了所有客户端请求的连接。如下图所示：</p>
<p>​                                <img src="/2017/09/19/Netty-In-Action-三/img3.png" alt="img3.png" title=""></p>
<p>&emsp; &emsp; 如图所示，EventLoopGroupA的唯一作用就是接受新的连接并将其注册到EventLoopGroupB上。Netty使用这种机制的原因是：当一个应用的请求非常大时，如果只有一个EventLoopGroup，那么当这个EventLoopGroup的EventLoop忙于处理已经建立连接IO事件时，新到来的连接就有可能会超时。而使用两个EventLoopGroup即使在qps较高的情况下也会接受所有的连接。因为接受新连接的EventLoop与处理已经建立连接的IO事件的EventLoop用的不是同一个线程。</p>
<blockquote>
<h4 id="EventLoopGroup和EventLoop"><a href="#EventLoopGroup和EventLoop" class="headerlink" title="EventLoopGroup和EventLoop"></a>EventLoopGroup和EventLoop</h4><p>&emsp; &emsp; EventLoopGroup可以包含多个EventLoop，根据这种关系，每一个Channel一旦被建立都会绑定到一个EventLoop上并且不会再改变。因为EventLoopGroup不会包含太多个EventLoop，所以会有很多个Channel共享一个EventLoop。也就是说如果EventLoop中的一个Channel性能比较低的话会影响所有绑定到这个EventLoop中的其他Channel。这就是Netty为什么要求所有的操作都是非阻塞的原因。</p>
</blockquote>
<p>&emsp; &emsp; Netty允许使用同一个EventLoopGroup同时处理IO事件并接受新的连接。如下图所示为ServerBootstrap中两个EventLoopGroup使用同一个实例的情况。</p>
<p>​                                <img src="/2017/09/19/Netty-In-Action-三/img4.png" alt="img4.png" title=""></p>
<h3 id="Channel-Handlers-and-Data-Flow"><a href="#Channel-Handlers-and-Data-Flow" class="headerlink" title="Channel Handlers and Data Flow"></a>Channel Handlers and Data Flow</h3><h4 id="将ChannelPipeline和handler组合在一起"><a href="#将ChannelPipeline和handler组合在一起" class="headerlink" title="将ChannelPipeline和handler组合在一起"></a>将ChannelPipeline和handler组合在一起</h4><p>&emsp; &emsp; ChannelHandler是Netty应用程序中最主要的部分，任何一个Netty应用至少包含一个ChannelHandler。ChannelHandler主要是用来处理ChannelPipeline中穿梭的数据流的。在Netty中，ChannelHandler作为一个父接口，ChannelInboundHandler及ChannelOutboundHandler继承自ChannelHandler，如下图所示：</p>
<p>​                                <img src="/2017/09/19/Netty-In-Action-三/img5.png" alt="ChanelHandler关系图" title="ChanelHandler关系图"></p>
<p>&emsp; &emsp; 在Netty中，数据流有两个方向，正如上图所示的流入(ChannelInboundHandler)和流出(ChannelOutboundHandler)。当数据从应用程序流向远端时我们称之为流出(outbound)，反之数据从远端流入我们的应用程序称之为流入(inbound)。</p>
<p>&emsp; &emsp; 为了使数据从一端流向另一端，一个或多个Handler将会在同一个方向上处理这些数据。这些Handler会在应用启动时添加，并且他们添加的顺序决定了何时处理数据。</p>
<p>&emsp; &emsp; 这些拥有特定顺序的ChannelHandler组成了所谓的ChannelPipeline。换句话说，ChannelPipeline是一系列ChannelHandler的组合。每一个ChannelHandler处理完数据后将其传送给下一个ChannelHandler直到最后一个。</p>
<p>​                <img src="/2017/09/19/Netty-In-Action-三/img6.png" alt="ChannelPipeline示例" title="ChannelPipeline示例"></p>
<p>&emsp; &emsp; 如上图所示，ChannelInboundHandler和ChannelOutboundHandler可以在ChannelPipeline中混排。在上图ChannelPipeline中，如果读取一条数据或者一个流入事件，将会在ChannelPipeline的头部将该条信息传输给第一个ChannelInboundHandler。这个ChannelInboundHandler会处理该事件并将其传输给CHannelPipeline中的下一个ChannelInboundHandler。当传输到最后一个ChannelInboundHandler时也就到达了ChannelPipeline的尾部，也就意味着所有的操作都完成了。</p>
<p>&emsp; &emsp; 反过来，所有输出事件都是从ChannelPipeline的尾部开始的，经过ChannelOutboundHandler传输直到ChannelPipeline头部。</p>
<p>&emsp; &emsp; 既然在ChannelPipeline中ChannelInboundHandler和ChannelOutboundHandler是混合在一起的，那他们是如何区分的呢。其实根据上面的ChannelHandler关系图可知，输入流(inbound)Handler与输出流(outbound)Handler实现了不同的接口。这也就意味着Netty可以跳过不是同一个类型的Handler只将数据传送给需要的Handler。</p>
<p>&emsp; &emsp; ChannelHandler被添加到ChannelPipeline中后，就会持有一个被称作ChannelHandlerContext的对象。一般来说我们只需要获取该对象的引用即可，但是在UDP等面向非连接的数据报协议中这样做是不安全的。这个对象稍后可以用来获取Channel对象但一般来说我们只是用它来读写数据。这意味着在Netty中有两种方式传输数据：直接向Channel中写数据或者直接写到ChannelHandlerContext对象中。不同的是前一种会导致数据从ChannelPipeline的尾部开始处理而后一种会导致数据从下一个Handler处理。</p>
<h3 id="近距离观察Handler-Encoders-Decoders和Domain-Logic"><a href="#近距离观察Handler-Encoders-Decoders和Domain-Logic" class="headerlink" title="近距离观察Handler(Encoders,Decoders和Domain Logic)"></a>近距离观察Handler(Encoders,Decoders和Domain Logic)</h3><p>&emsp; &emsp; 我们前面介绍过，Netty中有各种各样的Handler，不同的Handler功能取决于他们继承自哪一个接口(ChannelInboundHandler或ChannelOutboundHandler)。其实Netty提供了一系列的Adapter类来使事情变得简单，因为在pipline中，每一个Handler都要将事件推送给下一个Handler。而Adapter类则自动完成了这种操作，这样我们就可以只关心我们的业务逻辑。除了Adapter类，Netty还提供了编码(encode)/解码(decode)信息的功能。</p>
<blockquote>
<h4 id="适配类-Adapter-classes"><a href="#适配类-Adapter-classes" class="headerlink" title="适配类(Adapter classes)"></a>适配类(Adapter classes)</h4><p>Adapter类可以使我们更容易的编写代码。当我们需要些自己的ChannelHandler时建议继承Adapter类或者ecoder/decode类(其实也继承了Adapter类)。Netty提供了下列Adapter类</p>
<ul>
<li>ChannelHandlerAdapter</li>
<li>ChannelInboundHandlerAdapter</li>
<li>ChannelOutboundHandlerAdapter</li>
<li>ChannelDuplexHandlerAdapter</li>
</ul>
</blockquote>
<p>&emsp; &emsp; 我们着重观察一下encoder/decode以及SimpleChannelInboundHandler&lt; T >(ChannelInboundHandlerAdapter类)</p>
<h4 id="Encoders，decoders"><a href="#Encoders，decoders" class="headerlink" title="Encoders，decoders"></a>Encoders，decoders</h4><p>&emsp; &emsp; 当我们运用Netty接受或者传输数据时，我们需要将数据从一种类型转换为另一种类型。当我们接受一条消息时，我们需要将其从字节类型(bytes)转换为一个Java对象(decode)，当我们发送一条消息时我们需要将其从Java对象转换为字节类型(encode)。这种转换在网络传输中非常常见(bute-message,message-byte)，因为在网络中只能传输字节类型。</p>
<p>&emsp; &emsp; 在Netty中中多种encode/decode的基类，我们可以根据实际应用场景来决定使用哪个基类。一般来说，encode/decode的基类都有相似的名字，例如”MessageToByteEncoder”或者”ByteToMessageDecoder”。</p>
<p>&emsp; &emsp; 严格来说，其他的Handler也可以实现encoder和decoder的功能，但我们之前说过我们根据需要来选择不同的适配器类。实际上所有的decoder都实现或者继承了ChannelInboundHandlerAdapter或者ChannelInboundHandler。复写了“channelRead”方法，这个方法会读取流入(inbound)Channel的数据然后执行解码(decode)操作将解码过的信息传递给ChannelPipeline中的下一个ChannelInboundHandler。</p>
<p>&emsp; &emsp; 类似于流入信息，流出信息处理过程相似，encoder会将消息对象转化为字节流并传递给下一个ChannelOutboundHandler。</p>
<h4 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h4><p>&emsp; &emsp; 一般来说，我们最常用的handler主要用来处理解码(decode)过的信息，并加入我们的业务逻辑。创建这样的Handler，我们只需要简单地继承SimpleChannelInboundHandler&lt; T >，其中T表示我们的Handler可以处理的类型。在这个Handler中，我们可以根据自己需求复写不同的方法，所有方法参数都包含ChannelHandlerContext参数。</p>
<p>&emsp; &emsp; 在所有的基类方法中，最需要注意的是”channelRead0(ChannelHandlerContext,T)”方法，这个方法无论在哪里调用，T都是传递的信息，我们的应用可以对其随意处理。但需要注意的是即使我们用多线程来处理IO事件，我们也千万不能阻塞IO线程，因为这样有可能会影响程序性能。</p>
<blockquote>
<h4 id="阻塞操作"><a href="#阻塞操作" class="headerlink" title="阻塞操作"></a>阻塞操作</h4><p>&emsp; &emsp; 之前我们说过在Netty中千万不要阻塞IO，这也就意味着在我们的ChannelHandler中不能进行进行阻塞操作。幸运的是Netty提供了一个解决方案。在我们向ChannelPipeline中增加ChannelHandler时我们可以指定一个EventExecutorGroup，这个EventExecutorGroup会获得一个EventExecutor来执行该ChannelHandler的所有方法。不同的是EventExecutor会用一个不同的线程执行ChannelHandler的方法并在执行完毕后释放其绑定的EventLoop。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty In Action(二)]]></title>
      <url>/2017/09/13/Netty-In-Action-%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h3 id="第一个Netty程序"><a href="#第一个Netty程序" class="headerlink" title="第一个Netty程序"></a>第一个Netty程序</h3><p>本章将运用netty建立一个Echo Server和Client来熟悉Netty的特性</p>
<h3 id="Echo-Server"><a href="#Echo-Server" class="headerlink" title="Echo Server"></a>Echo Server</h3><p>一个Netty服务器包含以下两个主要部分：</p>
<ul>
<li>Bootstrapping：用来配置服务器熟悉，包括线程及端口。</li>
<li>Server Handler：Server组件，包括各种如何处理新的链接等各种业务逻辑的实现</li>
</ul>
<h4 id="启动Server"><a href="#启动Server" class="headerlink" title="启动Server"></a>启动Server</h4><p>&emsp; &emsp; 我们通过创建一个ServerBootStrap实例来启动一个Server。如下面代码所示，通过配置实例的端口号，线程(事件)模型以及处理各种业务逻辑的handler来实现一个Netty Server。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.port = port;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();                    <span class="comment">//1</span></div><div class="line">                b.group(group)                                                <span class="comment">//2</span></div><div class="line">                        .channel(NioServerSocketChannel.class)                        <span class="comment">//2</span></div><div class="line">                        .localAddress(<span class="keyword">new</span> InetSocketAddress(port))                    <span class="comment">//2</span></div><div class="line">                        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;        <span class="comment">//3</span></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                                ch.pipeline().addLast(</div><div class="line">                                        <span class="keyword">new</span> EchoServerHandler());                  <span class="comment">//4</span></div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                ChannelFuture f = b.bind().sync();              <span class="comment">//5</span></div><div class="line">                System.out.println(EchoServer.class.getName() + <span class="comment">//6 </span></div><div class="line">                        <span class="string">" started and listen on "</span> + f.channel()</div><div class="line">                        .localAddress());                       <span class="comment">//7 </span></div><div class="line">                f.channel().closeFuture().sync();               <span class="comment">//8</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;                                         <span class="comment">//9</span></div><div class="line">                group.shutdownGracefully().sync();              <span class="comment">//10</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">if</span> (args.length != <span class="number">1</span>) &#123;</div><div class="line">                System.err.println(</div><div class="line">                        <span class="string">"Usage: "</span>+EchoServer.class.getSimpleName() +</div><div class="line">                   <span class="string">"&lt;port &gt;"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">new</span> EchoServer(port).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建Server实例</li>
<li>指定NIO(异步IO)协议及网络地址</li>
<li>向channel pipline中添加handler</li>
<li>绑定服务器，等待服务器关闭并释放资源</li>
</ol>
<p>&emsp; &emsp; 为了运行一个服务器，首先要创建一个ServerBootstrao实例(1)，因为我们用的是NIO传输协议，所以需要指定NioEventLoopGroup来接受并处理新的连接，指定NioServerSocketChannel作为channel的类型，同时需要设置Server绑定的InetSocketAddress才能够接受新的连接(2)</p>
<p>&emsp; &emsp; 下一步，通过创建一个子channel(child channel， 3)来指定当一个新的连接到来时执行的动作，在这里运用了ChannelInitializer类型。由于ChannelPipeline中包含多个handler，所以我们将新建的EchoServerHandler添加到最后(4)。</p>
<p>&emsp; &emsp; 在(5)处，通过调用sync()方法来阻塞绑定我们的Server直到成功，同样在(8)，我们阻塞调用Server的close接口，直到Server关闭，在(10)，我们可以关闭EventLoopGroup并释放包括创建的线程在内的所有资源。</p>
<p>简化一下以上的步骤：</p>
<ul>
<li>创建一个用于启动Server的ServerBootstrap示例，并在后边绑定它</li>
<li>创建一个NIOEventLoopGroup实例来处理各种事件，例如接受新连接，接受新数据，写数据等等。</li>
<li>指定Server需要绑定的本地的InetSocketAddress</li>
<li>创建一个childHandler来指定每一个新连接到来时需要处理的业务逻辑</li>
<li>当上述所有步骤都完成后，调用ServerBootstrap.bind()来绑定Server。</li>
</ul>
<h4 id="实现业务逻辑"><a href="#实现业务逻辑" class="headerlink" title="实现业务逻辑"></a>实现业务逻辑</h4><p>&emsp; &emsp; 我们通过继承ChannelInboundHandlerAdapter并复写messageReceived方法来实现我们的接收数据并回写数据的业务逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Sharable</span></div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;       <span class="comment">//1</span></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;            </div><div class="line">           System.out.println(<span class="string">"Server received: "</span>+msg);</div><div class="line">           ctx.write(msg);                                                     <span class="comment">//2</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">           ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)</div><div class="line">                   .addListener(ChannelFutureListener.CLOSE);               <span class="comment">//3</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></div><div class="line"><span class="function"><span class="params">                                   Throwable cause)</span> </span>&#123;</div><div class="line">           cause.printStracktrace();                                        <span class="comment">//4</span></div><div class="line">           ctx.close();                                                     <span class="comment">//5</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<ol>
<li>Shareable注解说明该handler可以在多个channel之间共享</li>
<li>接受新的数据并将其回写，注意在这里还未将数据“flush”到客户端</li>
<li>将之前所有的数据flush到客户端，并关闭channel</li>
<li>打印异常日志</li>
<li>出现异常时关闭channel</li>
</ol>
<p>&emsp; &emsp; Netty的handler提供各种各样的接口“钩子”，我们可以通过复写不同的“钩子”来实现不同的业务逻辑，但这些钩子中只有channelRead是必须的。</p>
<h4 id="拦截异常"><a href="#拦截异常" class="headerlink" title="拦截异常"></a>拦截异常</h4><p>&emsp; &emsp; 处理复写channelRead方法来实现业务逻辑外，我们可以通过复写exceptionCaught来处理Exception或者Throwable等异常。</p>
<h3 id="实现echo-client"><a href="#实现echo-client" class="headerlink" title="实现echo client"></a>实现echo client</h3><p>一个echo client需要包括以下几个功能：</p>
<ul>
<li>连接到服务器</li>
<li>写数据</li>
<li>接受服务器传回的数据</li>
<li>关闭连接</li>
</ul>
<h4 id="启动client"><a href="#启动client" class="headerlink" title="启动client"></a>启动client</h4><p>&emsp; &emsp; 启动一个client与启动一个Server较为相似，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String host;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.host = host;</div><div class="line">            <span class="keyword">this</span>.port = port;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Bootstrap b = <span class="keyword">new</span> Bootstrap();                        <span class="comment">//1</span></div><div class="line">                b.group(group)                                        <span class="comment">//2</span></div><div class="line">                        .channel(NioSocketChannel.class)                     <span class="comment">//3</span></div><div class="line">                        .remoteAddress(<span class="keyword">new</span> InetSocketAddress(host, port))    <span class="comment">//4</span></div><div class="line">                        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;   <span class="comment">//5</span></div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span></span></div><div class="line"><span class="function">                                    <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                                ch.pipeline().addLast(</div><div class="line">                                        <span class="keyword">new</span> EchoClientHandler());            <span class="comment">//6</span></div><div class="line">                            &#125; &#125;);</div><div class="line">                ChannelFuture f = b.connect().sync();                 <span class="comment">//7</span></div><div class="line">                f.channel().closeFuture().sync();                     <span class="comment">//8</span></div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                group.shutdownGracefully().sync();                    <span class="comment">//9</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            <span class="keyword">if</span> (args.length != <span class="number">2</span>) &#123;</div><div class="line">                System.err.println(</div><div class="line">                        <span class="string">"Usage: "</span> + EchoClient.class.getSimpleName() +</div><div class="line">                                <span class="string">" &lt;host&gt; &lt;port&gt;"</span>);</div><div class="line">                <span class="keyword">return</span>; &#125;</div><div class="line">            <span class="comment">// Parse options.</span></div><div class="line">            <span class="keyword">final</span> String host = args[<span class="number">0</span>];</div><div class="line">            <span class="keyword">final</span> <span class="keyword">int</span> port = Integer.parseInt(args[<span class="number">1</span>]);</div><div class="line">            <span class="keyword">new</span> EchoClient(host, port).start();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>创建一个bootstrap</li>
<li>指定EventLoopGroup来处理客户端事件，运用NioEventLoopGroup</li>
<li>指定socket channle</li>
<li>设置需要连接的网络地址</li>
<li>利用ChannelInitializer指定channelHandler</li>
<li>将EchoClientHandler添加到ChannelPipeline中</li>
<li>调用sync()方法连接到远程服务器</li>
<li>阻塞等到连接关闭</li>
<li>关闭bootstrap和线程池，并释放所有资源</li>
</ol>
<p>几个重要的步骤：</p>
<ul>
<li>创建Bootstrap实例</li>
<li>创建NioEventLoopGroup并用来处理各种事件：创建新连接，读写数据等</li>
<li>指定需要连接的服务器地址</li>
<li>指定连接创建后调用的handler</li>
<li>以上步骤完成后，调用Bootstrap的connect方法连接到远程服务器。</li>
</ul>
<h4 id="实现客户端业务逻辑"><a href="#实现客户端业务逻辑" class="headerlink" title="实现客户端业务逻辑"></a>实现客户端业务逻辑</h4><p>&emsp; &emsp; 我们通过继承SimpleChannelInboundHandlerAdapter并复写其方法来实现客户端的业务逻辑。目前，我们只需要以下三个方法即可：</p>
<ul>
<li>channelActive()：当客户端与服务端连接建立时调用</li>
<li>channelRead0()：从服务端接收到数据时调用</li>
<li>exceptionCaught()：发生异常时调用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Sharable</span>                                                               <span class="comment">//1</span></div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClientHandler</span> <span class="keyword">extends</span></span></div><div class="line"><span class="class">            <span class="title">SimpleChannelInboundHandlerAdapter</span>&lt;<span class="title">ByteBuf</span>&gt; </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</div><div class="line">            ctx.write(Unpooled.copiedBuffer(<span class="string">"Netty rocks!"</span>, CharsetUtil.UTF_8); <span class="comment">//2</span></div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx,</span></span></div><div class="line"><span class="function"><span class="params">                                 ByteBuf in)</span> </span>&#123;</div><div class="line">            System.out.println(“Client received: “ + ByteBufUtil                <span class="comment">//3</span></div><div class="line">                    .hexDump(in.readBytes(in.readableBytes())));                </div><div class="line">        &#125;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,                  //<span class="number">4</span></span></span></div><div class="line"><span class="function"><span class="params">                                    Throwable cause)</span> </span>&#123;</div><div class="line">            cause.printStracktrace();</div><div class="line">            ctx.close();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ol>
<li>能够在多个channel共享handler</li>
<li>当连接建立时，向服务端发送数据</li>
<li>调用hexdump方法打印接收到的数据</li>
<li>打印异常</li>
</ol>
<p>&emsp; &emsp; 当连接建立时，channelActive方法将会被调用，并向服务端发送一条数据。当接到新的数据时channelRead0方法将会被调用，但需要注意的时客户端接收到的数据可能是不完整的，一个五字节的数据可能会分两次被传输。第一次传输连个字节，第二次传输三个字节。但在TCP协议或者其他面向流的协议来说，这种传输是可以保障顺序的。exceptionCaught被用来捕捉异常，并关闭连接。</p>
<blockquote>
<p>&emsp; &emsp; 或许你会疑问我们在EchoClientHandler为什么继承SimpleChannelInboundHandlerAdapter而不是像EchoServerHandler中继承ChannelInboundHandlerAdapter。最主要的原因是当你使用ChannelInboundHandlerAdapter时你需要自己释放资源，例如当使用ByteBuf时你需要调用ByteBuf.release()方法释放资源，而使用SimpleChannelInboundHandlerAdapter你不需要关心资源的释放，因为当channelRead0执行完毕时系统会自动释放资源。在Netty中，所有实现了ReferenceCounted接口的messages都会自动释放。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty in Action(一)]]></title>
      <url>/2017/09/11/Netty-in-Action-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="netty是什么"><a href="#netty是什么" class="headerlink" title="netty是什么"></a>netty是什么</h3><p>&emsp; &emsp; Nettt是一个基于Java NIO的client-server网络服务框架，人们可以利用netty快速地开发网络应用。同时netty相对于其他网络框架更加简单并且扩展性更强，这主要得益于其提供的简单易用的api将业务逻辑和网络处理代码解耦开来。能够使你更加专注于业务的实现而不需要太多关心网络底层实现。</p>
<h3 id="异步设计"><a href="#异步设计" class="headerlink" title="异步设计"></a>异步设计</h3><p>&emsp; &emsp; netty所有的api都是异步的。异步处理已经不是什么新鲜事了，众所周知，IO已经变为一个应用的瓶颈，而异步处理正是为了解决这个问题出现的。</p>
<h4 id="CallBacks机制"><a href="#CallBacks机制" class="headerlink" title="CallBacks机制"></a>CallBacks机制</h4><p>&emsp; &emsp; CallBacks机制经常应用于异步处理，人们可以指定方法执行完后的回调函数，在JavaScript中，回调机制是其语言的核心。下面代码展示了如何利用回调机制处理接受数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fetcher</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">fetchData</span><span class="params">(FetchCallback callback)</span></span>;</div><div class="line">&#125;</div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FetchCallback</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(Data data)</span></span>;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">         Fetcher fetcher = ...</div><div class="line">           fetcher.fetchData(<span class="keyword">new</span> FetchCallback() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               public void onData(Data data) &#123;                             #1</div><div class="line">                   System.out.println(<span class="string">"Data received: "</span> + data);</div><div class="line">               &#125;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               public void onError(Throwable cause) &#123;                      #2</div><div class="line">                   System.err.println(<span class="string">"An error accour: "</span> + cause.getMessage());</div><div class="line">               &#125;</div><div class="line">&#125;);</div><div class="line">... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#1 没有出现错误，调用onData</p>
<p>#2 出现错误信息，调用onError</p>
<p>&emsp; &emsp; 你可以将回调函数从当前线程移植到其他线程，但是并不能保证回调函数被执行。当你将多个异步回调函数串起来的时候会形成spaghetti code(管式代码)，有些人认为这样的代码很难读，但JavaScript以及Node.js都是这种风格。</p>
<h4 id="Futures机制"><a href="#Futures机制" class="headerlink" title="Futures机制"></a>Futures机制</h4><p>&emsp; &emsp; 异步处理使用的第二个机制是Future机制。一个Future对象只有在特定情况下才会有值，Future对象要么是调用者的返回结果，要么是一个异常。Java在java.util.concurrent包中提供了供其线程池机制使用的Future接口，例如当你使用ExecutorService.submit()提交一个Runable任务时，就可以返回一个Future对象，利用Future对象可以判断该任务是否完成。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">   Runnable task1 = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           doSomeHeavyWork();</div><div class="line">       &#125;</div><div class="line">... &#125;</div><div class="line">   Callable&lt;Interger&gt; task2 = <span class="keyword">new</span> Callable() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> doSomeHeavyWorkWithResul();</div><div class="line">       &#125;</div><div class="line">... &#125;</div><div class="line">   Future&lt;?&gt; future1 = executor.submit(task1);</div><div class="line">   Future&lt;Integer&gt; future2 = executor.submit(task2);</div><div class="line">   <span class="keyword">while</span> (!future1.isDone() || !future2.isDone()) &#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">// do something else</span></div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; CallBacks和Future是异步处理中最常用的两种机制，实际上无法判断两种机制的优劣，而Netty则会两种都提供，你可以自由选择使用哪种机制。</p>
<h3 id="JVM中的阻塞与非阻塞比较"><a href="#JVM中的阻塞与非阻塞比较" class="headerlink" title="JVM中的阻塞与非阻塞比较"></a>JVM中的阻塞与非阻塞比较</h3><p>&emsp; &emsp; 随着web应用的持续增长，如何提升网络应用的效率变得尤为重要。幸运的是从1.4版本开始，java提供了NIO API来供我们编写更有效率的网络应用。Java 7中又引入的NIO.2不仅仅是之前api的升级，同时也允许我们更加高效方便地编写异步代码。</p>
<blockquote>
<p>New or non-blocking?</p>
<p>The N in NIO is typically thought to mean non-blocking rather than new.NIO has beenaround for so long now that nobody calls it new IO anymore. Most people refer to it as non-blocking IO</p>
</blockquote>
<p>​                        <img src="/2017/09/11/Netty-in-Action-一/img1.png" alt="阻塞IO" title="阻塞IO"></p>
<p>&emsp; &emsp; 上图所示为典型的阻塞IO模式，一个线程处理一个网络连接，因此应用能够处理连接的个数是由JVM上允许建立的线程个数决定的。</p>
<p>​                        <img src="/2017/09/11/Netty-in-Action-一/img2.png" alt="非阻塞IO" title="非阻塞IO"><br>&emsp; &emsp; 再来看下非阻塞IO模式，上图运用selector机制来处理多个连接。下面通过一个回显服务器示例来讲解非阻塞及阻塞IO的区别。</p>
<h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainEchoServer</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            final ServerSocket socket = new ServerSocket(port);              #1</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    final Socket clientSocket = socket.accept();             #2</div><div class="line">                    System.out.println(<span class="string">"Accepted connection from "</span> +</div><div class="line">                            clientSocket);</div><div class="line">                    new Thread(new Runnable() &#123;                              #3</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">                                        <span class="keyword">new</span></div><div class="line">                                                InputStreamReader(clientSocket.getInputStream()));</div><div class="line">                                PrintWriter writer = <span class="keyword">new</span> PrintWriter(clientSocket</div><div class="line">                                        .getOutputStream(), <span class="keyword">true</span>);</div><div class="line">                                while (true) &#123;                                #4</div><div class="line">                                    writer.println(reader.readLine());</div><div class="line">                                    writer.flush();</div><div class="line">                                &#125;</div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    clientSocket.close();</div><div class="line">                                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                                    <span class="comment">// ignore on close</span></div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;).start();                                              #5</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p># 1 绑定监听端口</p>
<p># 2 阻塞至有新连接进来</p>
<p># 3 新建线程用来处理客户端连接</p>
<p># 4 从客户端读取数据并回写</p>
<p># 5 启动线程</p>
<p>&emsp; &emsp; 上述服务器代码要求每次连接进来一个请求就需要创建一个新的线程，即使使用线程池也仅能解决一时问题，不能再根本上解决问题：客户端的连接数取决于后台处理线程的个数。当连接数多时则会带来大问题。</p>
<h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>&emsp; &emsp; 在介绍NIO之前，我们先了解一些NIO的基本知识</p>
<h5 id="BYTEBUFFER"><a href="#BYTEBUFFER" class="headerlink" title="BYTEBUFFER"></a>BYTEBUFFER</h5><p>&emsp; &emsp; ByteBuffer在Netty中即为重要，其主要是用来缓存数据的。ByteBuffer既可以分配到堆内存中也可以分配到堆外内存。一般来说，堆外内存能够更加快速地传递给channel，但分配和释放会更耗时。新旧的NIO API对ByteBuffer提供了统一的管理。ByteBuffer能够实现无拷贝地在各个实例之间共享，同时允许对可见数据进行切片和其他操作处理。</p>
<blockquote>
<p>Slicing</p>
<p>Slicing a ByteBuffer allows to create a new ByteBuffer that share the same data as the intialByteBuffer but only expose a sub-region of it. This is useful to minimize memory copies whilestill only allow access to a part of the data</p>
</blockquote>
<p>ByteBuffer有以下几个重要的操作</p>
<ul>
<li>将数据写进ByteBuffer</li>
<li>调用ByteBuffer.flip()切换到读模式</li>
<li>从ByteBuffer中读取数据</li>
<li>调用ByteBuffer.clear()或者ByteBuffer.compact()来整理ByteBuffer内存</li>
</ul>
<p>&emsp; &emsp; 当往ByteBuffer中写数据时，ByteBuffer会通过更新buffer中write index的位置来跟踪buffer中的数据(也可以手动更新)。当需要从ByteBuffer中读取数据时，需要调用flip()来切换到读模式，flip()会将buffer的读起始位置设置为0，这样就可以读取buffer中所有数据了。</p>
<p>&emsp; &emsp; 为了能够再次向ByteBuffer中写数据，可以将buffer模式切换到写模式并调用任意下列两个方法。</p>
<ul>
<li>ByteBuffer.clear()：清除ByteBuffer</li>
<li>ByteBuffer.compact()：通过内存拷贝清除已经读过的数据</li>
</ul>
<p>&emsp; &emsp; ByteBuffer.compact()会将所有未读的数据拷贝到buffer的起始位置。如下所示为ByteBuffer的使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Channel inChannel = ....;</div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    bytesRead = inChannel.read(buf);			#1</div><div class="line">    <span class="keyword">if</span> (bytesRead != -<span class="number">1</span>) &#123;</div><div class="line">    buf.flip();									#2</div><div class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</div><div class="line">        System.out.print((char) buf.get());		#3</div><div class="line">    &#125;</div><div class="line">    buf.clear();								#4</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>);</div><div class="line">inChannel.close();</div></pre></td></tr></table></figure>
<p>#1 从channel中读取数据到ByteBuffer</p>
<p>#2 切换模式至读模式</p>
<p>#3 读取buffer中的数据，每次调用一个get()会将buffer当前位置更新+1</p>
<p>#4 切换buffer至写模式，使其可以重新写</p>
<h5 id="使用Selector模式"><a href="#使用Selector模式" class="headerlink" title="使用Selector模式"></a>使用Selector模式</h5><p>&emsp; &emsp; Selector可以监听多个IO是否可以读/写，这样一个Selector就可以用来处理多个连接，相比于阻塞IO每个连接占用一个线程，Selector模式更加高效。</p>
<p>通过以下几个操作就可以轻松运用Selector</p>
<ol>
<li>在channels上创建一个或多个Selector</li>
<li>在channel上注册需要监听的事件，目前支持四种事件<ul>
<li>OP_ACCEPT：socket-accept事件</li>
<li>OP_CONNECT：socket-connect事件</li>
<li>OP_READ：可读事件</li>
<li>OP_WRITE：可写事件</li>
</ul>
</li>
<li>channel注册后，调用Selector.select()方法阻塞直到上述注册的一个事件发生</li>
<li>当Selector.select()返回时，可以通过SelectionKey实例获取所有可操作的事件</li>
</ol>
<p>&emsp; &emsp; 下面EchoServer是基于非阻塞Selector的服务器代码，运用这个版本的Server可以运用一个线程处理上千个连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNioEchoServer</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">           System.out.println(<span class="string">"Listening for connections on port "</span> + port);</div><div class="line"> ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">        ServerSocket ss = serverChannel.socket();</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">        ss.bind(address);                                                #1</div><div class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">Selector  selector = Selector.open();</div><div class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        #2</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                selector.select();                                       #3</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                ex.printStackTrace();</div><div class="line">                <span class="comment">// handle in a proper way</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">            Set readyKeys = selector.selectedKeys();                     #4</div><div class="line">            Iterator iterator = readyKeys.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SelectionKey key = (SelectionKey) iterator.next();</div><div class="line">                iterator.remove();                                       #5</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                      ServerSocketChannel server = (ServerSocketChannel)key.channel();</div><div class="line">                      SocketChannel client = server.accept();			#6</div><div class="line">                      System.out.println(<span class="string">"Accepted connection from"</span> + client);</div><div class="line">                      client.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                      client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));                         					  #7</div><div class="line">                    &#125;</div><div class="line">                    if (key.isReadable()) &#123;                              #8</div><div class="line">                        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</div><div class="line">                        client.read(output);                             #9</div><div class="line">                    &#125;</div><div class="line">                    if (key.isWritable()) &#123;                             #10</div><div class="line">                        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</div><div class="line">                        output.flip();</div><div class="line">                        client.write(output);                           #11</div><div class="line">                        output.compact();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                    key.cancel();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        key.channel().close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException cex) &#123;</div><div class="line">                   &#125;</div><div class="line">				&#125; </div><div class="line">            &#125;</div><div class="line">		&#125; </div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#1 绑定Server的port</p>
<p>#2 注册channel的OP_ACCEPT Selector事件，监听新连接</p>
<p>#3 阻塞直到有新的连接事件到来</p>
<p>#4 获取所有可操作的SelectedKey实例</p>
<p>#5 遍历SelectedKey实例，将遍历过的去除</p>
<p>#6 获取新的连接</p>
<p>#7 将新的连接注册到Selector中，并监听读/写事件</p>
<p>#8 检查SelectKey是否可读</p>
<p>#9 读数据</p>
<p>#10 检测是否可写</p>
<p>#11 写数据</p>
<p>&emsp; &emsp; 上述代码实现起来比较繁琐，新的NIO API去掉了大部分繁琐的过程，使实现起来更加简单明了</p>
<h4 id="基于NIO-2的EchoServer"><a href="#基于NIO-2的EchoServer" class="headerlink" title="基于NIO.2的EchoServer"></a>基于NIO.2的EchoServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNio2EchoServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Listening for connections on port "</span> + port);</div><div class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverChannel =</div><div class="line">                AsynchronousServerSocketChannel.open();</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">        serverChannel.bind(address);                                    #1</div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span></div><div class="line">                CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;                #2</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel channel, Object attachment)</span> </span>&#123;</div><div class="line">                        serverChannel.accept(null, this);                       #3</div><div class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</div><div class="line">                        channel.read(buffer, buffer,</div><div class="line">                                new EchoCompletionHandler(channel));            #4</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span> <span class="params">(Throwable throwable, Object attachment)</span></span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                serverChannel.close();                              #5</div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                <span class="comment">// ingnore on close</span></div><div class="line">                            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                                latch.countDown();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;); <span class="keyword">try</span></div><div class="line"></div><div class="line">                    &#123;</div><div class="line">                        latch.await();</div><div class="line">                    &#125; <span class="keyword">catch</span>(</div><div class="line">                    InterruptedException e)</div><div class="line"></div><div class="line">                    &#123;</div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoCompletionHandler</span> <span class="keyword">implements</span></span></div><div class="line"><span class="class">                <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel channel;</div><div class="line"></div><div class="line">            EchoCompletionHandler(AsynchronousSocketChannel channel) &#123;</div><div class="line">                <span class="keyword">this</span>.channel = channel;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</div><div class="line">                buffer.flip();</div><div class="line">                channel.write(buffer, buffer, new CompletionHandler&lt;Integer,    #6</div><div class="line">                        ByteBuffer&gt;() &#123;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</div><div class="line">                            channel.write(buffer, buffer, this);            #7</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            buffer.compact();</div><div class="line">                            channel.read(buffer, buffer,</div><div class="line">                                    EchoCompletionHandler.this);             #8</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            channel.close();</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="comment">// ingnore on close</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    channel.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="comment">// ingnore on close</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>#1 绑定Server的port</p>
<p>#2 监听新连接到来，一旦有新的连接接入则会调用CompletionHandler</p>
<p>#3 重新监听连接接入事件</p>
<p>#4 在channel上触发读操作，一单有数据可读EchoCompletionHandler将会被触发</p>
<p>#5 出现错误时关闭channel</p>
<p>#6 注册写回调事件，通#4</p>
<p>#7 当buffer中还有数据时再次注册写事件</p>
<p>#8 同#4，注册CompletionHandler回调读事件</p>
<p>&emsp; &emsp; 上述代码看起来要比之前的更加复杂，按NIO2.0自己实现了loop事件，我们在使用的时候只需要简单地注册自己感兴趣的事件即可。</p>
<h3 id="非阻塞应用存在的问题以及Netty是如何解决的"><a href="#非阻塞应用存在的问题以及Netty是如何解决的" class="headerlink" title="非阻塞应用存在的问题以及Netty是如何解决的"></a>非阻塞应用存在的问题以及Netty是如何解决的</h3><h4 id="跨平台及兼容性问题"><a href="#跨平台及兼容性问题" class="headerlink" title="跨平台及兼容性问题"></a>跨平台及兼容性问题</h4><p>&emsp; &emsp; 非阻塞应用一般都会有跨平台问题，一个NIO应用在Linux上可以运行但在Window无法运行，同时还需要对低版本的兼容。NIO2.0只能在java7之后的版本运行，但它提供了一套统一的管理api，使其也能够在更低完本的jdk上运行，只不过有些功能受到了限制。</p>
<h4 id="修复e-poll-bug"><a href="#修复e-poll-bug" class="headerlink" title="修复e-poll bug"></a>修复e-poll bug</h4><p>&emsp; &emsp; 在Linux系统上，Java的NIO的Selector运用的是较为高效的e-poll机制，但是当连接较少时会存在一个很严重的bug导致cpu占用率很高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">          int selected = selector.select();                                #1</div><div class="line">          Set&lt;SelectedKeys&gt; readyKeys = selector.selectedKeys();</div><div class="line">          Iterator iterator = readyKeys.iterator();                        #2</div><div class="line">          while (iterator.hasNext()) &#123;                                     #3</div><div class="line">                 ... 													   #4</div><div class="line">			&#125; </div><div class="line">      &#125;</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; 在Linux系统中，#1处并没有阻塞，而是返回0，这样while循环会到时cpu上升到100%，即使到现在，这个问题仍然存在，不过幸运的是Netty避免了这个问题。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Java线程池]]></title>
      <url>/2017/08/15/%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  Java中线程池是运用场景最多的并发框架，几乎所有的多任务或者异步并发任务都可以使用Java的线程池。在实际应用中，Java线程池的应用场景主要有以下几个：</p>
<ul>
<li>单任务执行时间短，并发量高</li>
<li>定时循环任务或者延迟任务</li>
<li>处理可以分解的大任务(ForkJoinPool)</li>
</ul>
<p>  在开发过程中合理地使用线程池可以带来的好处有以下几种:</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>  Executor 框架是从 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，更易管理，效率更高。Executor框架提供了Executors工厂方法，通过Executors可以创建我们需要的线程池。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image1.png" alt="Executor架构" title="Executor架构"></p>
<p>  Executor只提供了一个execute()方法提交任务，而其继承接口ExecutorService则丰富了其接口，不但提供了不同的任务提交方法，还提供了对线程池的管理的方法接口。AbstractExecutorService和ScheduledExecutorService是对ExecutorService更进一步的实现。而最终可以使用的实体类只有ThreadPoolExecutor和ScheduledThreadPoolExecutor。ThreadPoolExecutor会维护一个线程池，用户可以向线程池提交任务同时可以调用shunDown函数来关闭线程池，而ScheduledThreadPoolExecutor则专门用来执行定时或者循环任务，用户可以通过设置任务的执行时间来定时执行任务或者设置任务执行间隔时间来循环地执行任务。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>  ThreadPoolExecutor通过execute来提交任务，通过corePoolSize和maximumPoolSize来控制线程池中线程的数量，通过设置keepAliveTime来控制线程空闲时长，通过BlockingQueue来存储用户提交的任务，通过RejectExecutionHandler来定义任务拒绝策略。</p>
<h4 id="ThreadPoolExecutor组成"><a href="#ThreadPoolExecutor组成" class="headerlink" title="ThreadPoolExecutor组成"></a>ThreadPoolExecutor组成</h4><p>  在详细介绍ThreadPoolExecutor之前，我们先了解下ThreadPoolExecutor的一些重要组成变量及内部类。</p>
<p>重要成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"><span class="comment">//非核心线程空闲时长</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</div><div class="line"><span class="comment">//是否允许回收核心线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</div><div class="line"><span class="comment">//线程池核心线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</div><div class="line"><span class="comment">//线程池最大线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</div></pre></td></tr></table></figure>
<ul>
<li><p>ctl是ThreadPoolExecutor类的核心，由两部分组成，高3位表示线程池的状态，低29位表示线程池中的线程数。如下图所示为ctl结构图</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image2.png" alt="ctl结构图" title="ctl结构图"></p>
</li>
<li><p>keepAliveTime：非核心线程空闲时长，如果非核心线程在keepAliveTime内没有获得可执行的任务，则会被回收</p>
</li>
<li>allowCoreThreadTimeOut：是否回收核心线程，如果为true表示可以回收核心线程，核心线程回收逻辑同非核心线程相同</li>
<li>corePoolSize：线程池允许的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数量</li>
</ul>
<p>Worker线程内部类</p>
<p>  Worker实现了Runnable接口，是对线程池中线程的一个简单封装。当一个worker线程被创建并启用时，会调用ThreadPoolExecutor的runWorker方法来开始执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            runWorker(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor剖析"><a href="#ThreadPoolExecutor剖析" class="headerlink" title="ThreadPoolExecutor剖析"></a>ThreadPoolExecutor剖析</h4><p>  我们会从以下几个方面着手分析ThreadPoolExecutor</p>
<ul>
<li>线程池状态(线程池的生命周期)</li>
<li>execute任务提交过程(任务的流向)</li>
<li>Worker线程创建逻辑(线程的生命周期)</li>
<li>Worker线程销毁逻辑(线程的生命周期)</li>
</ul>
<h5 id="线程池状态-线程池的生命周期"><a href="#线程池状态-线程池的生命周期" class="headerlink" title="线程池状态(线程池的生命周期)"></a>线程池状态(线程池的生命周期)</h5><p>  ThreadPoolExecutor通过ctl的高三位存储线程池的状态，线程池共有五中状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;	<span class="comment">//29</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">//00011111111111111111111111111111 = 2^29 - 1</span></div><div class="line"><span class="comment">// runState is stored in the high-order bits</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;	<span class="comment">//11100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	<span class="comment">//00000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//00100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01100000000000000000000000000000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;	<span class="comment">//获取线程池状态</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;	<span class="comment">//获取线程池中线程的个数</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;		<span class="comment">//根据线程池状态和线程个数组合称ctrl</span></div></pre></td></tr></table></figure>
<ul>
<li>RUNNING：线程池正常运行，可接受新的任务或者消费队列中的任务</li>
<li>SHUTDOWN：线程池关闭(主线程调用shutdown方法)，不再接受新的任务，但会继续执行队列中的任务</li>
<li>STOP：线程池终止(主线程调用shudownNow方法)，既不接受新的任务也不再执行队列中的任务</li>
<li>TIDYING：所有的任务都被终止，线程数为0，所有线程都被终止。当线程池转换到TIDYING状态时会执行terminated(默认什么都不执行，由子类复写)方法</li>
<li>TERMINATED：TIDYING状态下执行完terminated方法，线程池转化为此状态</li>
</ul>
<p>线程池状态转换图:</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image3.png" alt="状态转换图" title="状态转换图"></p>
<h5 id="execute任务提交过程-任务的流向"><a href="#execute任务提交过程-任务的流向" class="headerlink" title="execute任务提交过程(任务的流向)"></a>execute任务提交过程(任务的流向)</h5><p>  execute方法用于用户提交任务，线程池对任务有三种处理方式:新建一个线程执行任务、放入queue队列或者拒绝任务执行。由于execute方法执行的时候并未加锁，因此会在多个地方进行double check线程池的状态。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image4.png" alt="任务提交流程图" title="任务提交流程图"></p>
<ol>
<li>工作线程数(workCount)小于核心线程数时新建一个核心线程执行提交的任务</li>
<li>工作线程数大于等于核心线程数并且任务队列(WorkQueue)未满时，将用户新提交的任务放入任务队列</li>
<li>任务队列满并且工作线程数小于最大线程数时，创建一个新的非核心线程执行提交的任务</li>
<li>工作线程数等于最大线程数且任务队列满时，则拒绝提交的任务</li>
</ol>
<p>BlockingQueue:任务存储队列，主要有以下几种队列</p>
<ul>
<li>LinkedBlockingQueue:无界的FIFO队列(maximumPoolSize失效)</li>
<li>ArrayBlockingQueue:有界FIFO队列</li>
<li>SynchronousQueue:不存储元素的阻塞队列，插入操作必须等待移除操作完成后才能执行，任务吞吐量比较高</li>
<li>ProorityBlockingQueue:具有优先级的无界阻塞队列</li>
</ul>
<p>RejectExecutionHandler:线程池不能接受新线程时拒绝策略,默认有以下几种策略</p>
<ul>
<li>AbortPolicy:直接抛异常（默认）</li>
<li>CallerRunsPolicy:由创建线程池的线程执行当前提交的任务</li>
<li>DiscardOldestPolicy:抛弃队列头的任务</li>
<li>DiscardPolicy:直接抛弃</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;    </div><div class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">// 线程池中线程数小于核心线程数(step1)</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();  <span class="comment">//如果增加线程失败，说明线程池状态发生变化，需要重新获取线程池状态</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程池正常，将任务放进队列中(step2)</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">//需要进行double check，防止在执行该方法时线程状态变化</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//如果线程处于非运行状态则需要移除该任务，并调用拒绝策略拒绝任务</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="comment">//线程池中线程数为0说明在执行该方法时主线程执行了shutdown操作，需要重新启动一个线程执行队列中的任务(由于workQueue.offer(command)执行成功，因此队列中至少有一个任务)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))	<span class="comment">//增加非核心线程(step3)</span></div><div class="line">        reject(command);    				<span class="comment">//拒绝任务(step4)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述为execute的源码，其中step1-step4对应上述的任务提交流程图的四个步骤</p>
<h5 id="Worker线程创建-线程生命周期"><a href="#Worker线程创建-线程生命周期" class="headerlink" title="Worker线程创建(线程生命周期)"></a>Worker线程创建(线程生命周期)</h5><p>  通过上边的execue的提交流程可知，ThreadPoolExecutor会在两种情况下新增一个Worker线程。</p>
<ul>
<li>线程池中线程数小于核心线程数</li>
<li>任务队列满并且线程池中线程数小于最大线程数</li>
</ul>
<p>  新增Worker主要有以下三个步骤:</p>
<ul>
<li>线程池状态检查：非RUNNING和SHUTDOWN状态下线程池拒绝创建新线程并拒绝提交任务，SHUTDOWN状态下不允许提交新任务，但是需要注意的是<strong>即使线程池处于SHUTDOWN状态，但如果任务队列中还有任务未执行完成，并且此时线程池中线程数量为0，线程池允许新建一个线程来消费任务队列中的任务</strong></li>
<li>线程池中线程数量检查：线程池线程数量 &gt;= CAPACITY || 核心线程数 &gt;= corePoolSize || 总线程数  &gt;= maximumPoolSize 不允许创建线程；</li>
<li>创建新线程并将其加到线程池中，同时调用start()启动线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">/*******************  1. 状态检查begin   *****************************/</span></div><div class="line"></div><div class="line">        <span class="comment">//等同于 rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></div><div class="line">        <span class="comment">//等同于 </span></div><div class="line">        <span class="comment">// 1. rs &gt; SHUTDOWN：不允许新增线程，不接受新任务</span></div><div class="line">        <span class="comment">// 2. rs = SHUTDOWN &amp;&amp; firstTask != null：不允许新增线程，并拒绝新任务</span></div><div class="line">        <span class="comment">// 3. rs = SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty(): 线程池关闭，任务队列中的任务为空，不再允许提交新的任务</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/*******************  2. 线程池数量检查begin     *****************************/</span></div><div class="line">      	<span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">//1. 线程数 &gt;= CAPACITY</span></div><div class="line">          	<span class="comment">//2. 线程数 &gt;= corePoolSize时不允许创建核心线程</span></div><div class="line">          	<span class="comment">//3. 线程数  &gt;= maximumPoolSize 不允许创建非核心线程</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//增加线程数成功，跳出retry循环</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">//re-check线程池状态，不一致说明触发了线程池状态变更，需要重新验证是否需要创建新的线程</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">/*******************  3.创建并运行线程begin     *****************************/</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// 1. 线程池处于正常运行时，新增线程ok</span></div><div class="line">                <span class="comment">// 2. rs = SHUTDOWN状态下，只有firstTask为null时才允许新增线程,见execute(),线程池关闭并且线程数为0</span></div><div class="line">                <span class="comment">//但任务队列中还有未完成的任务.</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                t.start();  <span class="comment">//启动线程</span></div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Worker线程销毁逻辑-线程生命周期"><a href="#Worker线程销毁逻辑-线程生命周期" class="headerlink" title="Worker线程销毁逻辑(线程生命周期)"></a>Worker线程销毁逻辑(线程生命周期)</h5><p>  ThreadPoolExecutor通过addWorker函数新增并启动一个工作线程，通过上边的Worker源码可知，Worker线程执行的是ThreadPoolExecutor.runWorker(Worker)里面的逻辑。runWorker主要做了以下几个工作:</p>
<ul>
<li>获取需要执行的任务，初始化任务或者从任务队列中获取的任务</li>
<li>检查线程池状态，保证线程池能够及时中断</li>
<li>beforeExecute—&gt;task.run()—&gt;afterExecute</li>
<li>退出while循环后，执行processWorkerExit方法，中断一个空闲线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">   	Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;    <span class="comment">//先执行初始化时的任务</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">//主要用来判断线程是正常结束还是异常结束，true为异常结束，在processWorkerExit中用来标志是否将线程池中的线程数减一</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// task是控制线程周期的重要因素</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">          	<span class="comment">//判断线程池状态，中断线程</span></div><div class="line">          	<span class="comment">// 线程池状态&gt;=STOP并且线程未被中断，需要中断线程</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//执行自定义的任务执行前操作，默认什么也不执行</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//执行任务</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                  	<span class="comment">//任务执行后执行的操作，默认什么也不执行</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      	<span class="comment">//线程退出后执行清理工作</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  由上述源码可知线程池中的线程通过while循环来保证线程正常进行，任务来源是初始化任务firstTask或者通过getTask(从任务队列中获取任务)，当线程获取到的任务为空时则退出while循环，结束线程生命周期。所以task是否为空控制着线程的生命周期，而task的来源是getTask函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回null则退出线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">      	<span class="comment">// 1. rs &gt; SHUTDOWN：线程池关闭，回收该线程</span></div><div class="line">      	<span class="comment">// 2. rs = SHUTDOWN &amp;&amp; workQueue.isEmpty():任务队列中任务执行完毕，回收该线程</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// timed表示是否需要回收该线程，如果allowCoreThreadTimeOut设置为true则无论当前线程数</span></div><div class="line">        <span class="comment">// 设置多少都需要回收，否则只有当线程池中线程数大于corePoolSize时才需要回收</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        <span class="comment">//需要回收线程时，则将线程数减一，并返回null，在runWorker中回收线程</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//1：如果timed为true，该线程需要回收，通过将workQueue.poll的超时时间设置为</span></div><div class="line">            <span class="comment">// keepAliveTime来保证返回的task是否为空，从而来判断该线程是否需要回收</span></div><div class="line">            <span class="comment">// 2：timed为false，则阻塞获取workQueue，直到线程中断或者获取到任务</span></div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  由上述源码可知getTask是通过workQueue的poll来hold当前工作线程keepAlive时长，从而实现工作线程空闲keepAliveTime能够及时回收。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image5.png" alt="getTask" title="getTask"></p>
<h3 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h3><p>  ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，所以其新增和回收线程逻辑，执行任务方式都沿用了ThreadPoolExecutor的逻辑。ScheduledThreadPoolExecutor之所以能够执行定时任务和延迟任务，主要是其自定义实现了一个DelayQueue并封装了一个ScheduledFutureTask(extend FutureTask)，其中DelayWorkQueue维护着一个最小堆，最先需要执行的任务在堆顶。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>  ScheduledThreadPoolExecutor本质是一个ThreadPoolExecutor，其构造函数直接t通过super来完成对象的初始化。默认ScheduledThreadPoolExecutor的maximumPoolSize为Integer.MAX_VALUE，keepAliveTime=0，任务队列为DelayedWorkQueue。但是由于DelayedWorkQueue无限增长(最大值Integer.MAX_VALUE),其相当于一个无界队列，所以设置maximumPoolSize基本上是无效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><p>  ScheduledFutureTask是ScheduledThreadPoolExecutor对任务的封装，其中包含了该任务的类型(period)、下次需要执行的时间(time)以及在任务队列中的位置(heapInex)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">  	<span class="comment">//入队列的序号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line">  	<span class="comment">//任务执行的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</div><div class="line"></div><div class="line">  	<span class="comment">//任务类型</span></div><div class="line">  	<span class="comment">//正数:按固定频率执行</span></div><div class="line">  	<span class="comment">//0：非重复执行的任务</span></div><div class="line">  	<span class="comment">// 负数：按固定延迟执行</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</div><div class="line"></div><div class="line">    <span class="comment">/** The actual task to be re-enqueued by reExecutePeriodic */</span></div><div class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  	<span class="comment">// 在任务队列数组中的索引</span></div><div class="line">    <span class="keyword">int</span> heapIndex;</div></pre></td></tr></table></figure>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p>  DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p>
<h5 id="排序规则："><a href="#排序规则：" class="headerlink" title="排序规则："></a>排序规则：</h5><ul>
<li>执行时间距离当前时间越近，越靠前</li>
<li>如果执行时间相同，则先执行插入时间靠前的任务。</li>
</ul>
<h4 id="获取任务-take"><a href="#获取任务-take" class="headerlink" title="获取任务(take)"></a>获取任务(take)</h4><p>  take函数主要是获取任务队列最小堆中的第一个任务，其使用了leader-follower模式，关于leader-follower模式可以参考这篇<a href="http://blog.csdn.net/goldlevi/article/details/7705180" target="_blank" rel="external">博客</a>。</p>
<blockquote>
<p>leader-follower模式中，所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<ul>
<li>获取任务队列堆顶元素，如果为null则进入wail状态，等待offer的signal唤醒</li>
<li>如果堆顶任务执行时间小于当前时间，则返回堆顶任务</li>
<li>如果leader为空，则将当前线程设置为leader，并等待至堆顶任务执行时间</li>
<li>如果leader已存在，则进入wait状态，等待被唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)	<span class="comment">//队列中没有任务，需要等待offer函数唤醒</span></div><div class="line">                available.await();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)	<span class="comment">//到任务的执行时间，执行该任务</span></div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)	<span class="comment">//当leader线程不为null时说明有leader线程在等待第一个任务，其他线程进入wait状态</span></div><div class="line">                    available.await();</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;	<span class="comment">//设置为leader线程</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      <span class="comment">//等待delay时间，</span></div><div class="line">                        available.awaitNanos(delay);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;	<span class="comment">//将leader设置为null并在下一个循环中获取任务</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();	<span class="comment">//唤醒其他线程</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="新增任务"><a href="#新增任务" class="headerlink" title="新增任务"></a>新增任务</h4><p>  ScheduledThreadPoolExecutor支持三种新增任务的方式，新增普通延迟任务，新增固定频率执行任务，新增固定频率执行的延迟任务。</p>
<ol>
<li>通过schedule函数直接新增一条延迟执行的任务(ScheduleThreadPoolExecutor.schedule)</li>
<li>通过scheduleAtFixedRate新增一条按固定频率执行的任务(ScheduleThreadPoolExecutor.scheduleAtFixedRate)</li>
<li>通过scheduleWithFixedDelay新增一条固定频率执行的延迟任务(ScheduleThreadPoolExecutor.scheduleWithFixedDelay)</li>
</ol>
<p>  ScheduledThreadPoolExecutor是如何实现定时任务和延迟任务的呢？由上面可知ScheduledThreadPoolExecutor重新封装了task也就是ScheduledFutureTask，而定时和延迟任务的执行就在ScheduledFutureTask的run中完成的。任务下次执行时间:</p>
<ul>
<li><p>非周期循环任务，无下次执行时间</p>
</li>
<li><p>定时周期任务：上次执行时间+延迟时间</p>
</li>
<li><p>延迟周期任务：当前时间+延迟时间</p>
<p>​    <img src="/2017/08/15/浅谈Java线程池/image6.png" alt="周期任务执行时间序列图" title="周期任务执行时间序列图"></p>
</li>
</ul>
<img src="/2017/08/15/浅谈Java线程池/image7.png" alt="任务执行步骤" title="任务执行步骤">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">//判断是否是定时任务</span></div><div class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</div><div class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</div><div class="line">        cancel(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</div><div class="line">      	<span class="comment">//非循环任务，直接执行</span></div><div class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</div><div class="line">      	<span class="comment">//循环任务任务，执行完后设置下次执行的时间</span></div><div class="line">        setNextRunTime();</div><div class="line">        reExecutePeriodic(outerTask);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">long</span> p = period;</div><div class="line">  			<span class="comment">//循环任务直接在本次执行时间上加上时间间隔</span></div><div class="line">            <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</div><div class="line">                time += p;</div><div class="line">            <span class="keyword">else</span></div><div class="line">              <span class="comment">//延迟定时任务则将当前时间+延迟时间作为下次执行的时间</span></div><div class="line">                time = triggerTime(-p);</div><div class="line">        &#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> now() +</div><div class="line">            ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Executors工厂类"><a href="#Executors工厂类" class="headerlink" title="Executors工厂类"></a>Executors工厂类</h3><p>  Executors是一个线程池的工厂类，用户可以通过调用其静态函数来创建不同的线程池，常用的线程池有以下几个:</p>
<ol>
<li><p>newFixedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newFixedThreadPool返回特定线程数的线程池，但需要注意的是<strong>newFixedThreadPool的任务队列是LinkedBlockingQueue无界队列，如果生产者速度大于消费者会造成jvm频繁full gc</strong></p>
</li>
<li><p>newSingleThreadExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newSingleThreadExecutor返回只有一个线程的线程池，其并没有返回ThreadPoolExecutor对象，而是返回FinalizableDelegatedExecutorService的一个代理类，主要是为了屏蔽一些不必要的操作，例如allowCoreThreadTimeOut()。通newFixedThreadPool一样，newSingleThreadExecutor也是使用LinkedBlockingQueue无界队列来存储任务的。</p>
</li>
<li><p>newCachedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newCachedThreadPool利用SynchronousQueue作为任务队列，核心线程数设置为0，线程最大空闲时间为60s。newCachedThreadPool实现了一个线程缓存池，当提交任务比较频繁时可以快速创建新的线程处理任务，任务提交不频繁时又可以优雅地回收线程。其适用于处理吞吐量比较高的场景。</p>
</li>
<li><p>newScheduledThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newScheduledThreadPool返回一个定时执行任务的线程池，类似于Timer。</p>
</li>
</ol>
<h2 id="线程池分配"><a href="#线程池分配" class="headerlink" title="线程池分配"></a>线程池分配</h2><p>  合理地配置线程池，需要对任务的特性进行分析，可以从以下几个角度进行分析</p>
<ol>
<li><p>任务的性质：CPU密集型、IO密集型还是混合密集型。一般来说CPU密集型可以将线程池数设置为CPU+1，IO密集型可以将线程数设置为2*CPU，混合型的最好能够拆分成CPU密集型和IO密集型两个线程池，这种计算方式适用于一台机器上只跑一个服务的情况。</p>
</li>
<li><p>多应用，多任务线程计算公式：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目或者进一步转化后:最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
</li>
<li><p>任务优先级：高、中、低任务优先级，可以使用PriorityBlockQueue来存储任务</p>
</li>
<li><p>任务执行的时长：长、中、短等，不同时长的任务可以分发给不同的线程池来执行，或者使用PriorityBlockQueue来保证执行时间短的任务先执行。</p>
</li>
<li><p>任务的依赖：是否依赖其他资源，可以根据所依赖的资源的类型来判断执行任务的类型。</p>
<p>​</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ScheduledThreadPoolExecutor源码分析]]></title>
      <url>/2017/08/11/ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  对于一般的多任务执行，ThreadPoolExecutor可以满足大部分需求。但是有时候我们需要定时或者延迟地去执行一个任务，这个时候ThreadPoolExecutor已经不能满足我们的需求了，所以Java提供了ScheduledThreadPoolExecutor来执行定时或延迟任务。</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>​    ScheduledThreadPoolExecutor继承了<a href="/2017/08/08/ThreadPoolExecutor源码分析/">ThreadPoolExecutor</a>，所以其新增和回收线程逻辑，执行任务方式都沿用了ThreadPoolExecutor的逻辑。ScheduledThreadPoolExecutor之所以能够执行定时任务和延迟任务，主要是其自定义实现了一个DelayQueue并封装了一个ScheduledFutureTask(extend FutureTask)。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>  ScheduledThreadPoolExecutor本质是一个ThreadPoolExecutor，其构造函数直接t通过super来完成对象的初始化。默认ScheduledThreadPoolExecutor的maximumPoolSize为Integer.MAX_VALUE，keepAliveTime=0，任务队列为DelayedWorkQueue。但是由于DelayedWorkQueue是无界队列，所以设置maximumPoolSize是无效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><p>  ScheduledFutureTask是ScheduledThreadPoolExecutor对任务的封装，其中包含了该任务的类型(period)、下次需要执行的时间(time)以及在任务队列中的位置(heapInex)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** Sequence number to break ties FIFO */</span></div><div class="line">  	<span class="comment">//入队列的序号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line"></div><div class="line">    <span class="comment">/** The time the task is enabled to execute in nanoTime units */</span></div><div class="line">  	<span class="comment">//任务执行的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Period in nanoseconds for repeating tasks.  A positive</span></div><div class="line"><span class="comment">     * value indicates fixed-rate execution.  A negative value</span></div><div class="line"><span class="comment">     * indicates fixed-delay execution.  A value of 0 indicates a</span></div><div class="line"><span class="comment">     * non-repeating task.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  	<span class="comment">//任务类型</span></div><div class="line">  	<span class="comment">//正数:按固定频率执行</span></div><div class="line">  	<span class="comment">//0：非重复执行的任务</span></div><div class="line">  	<span class="comment">// 负数：按固定延迟执行</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</div><div class="line"></div><div class="line">    <span class="comment">/** The actual task to be re-enqueued by reExecutePeriodic */</span></div><div class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Index into delay queue, to support faster cancellation.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  	<span class="comment">// 在任务队列数组中的索引</span></div><div class="line">    <span class="keyword">int</span> heapIndex;</div></pre></td></tr></table></figure>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p>  DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p>
<h5 id="排序规则："><a href="#排序规则：" class="headerlink" title="排序规则："></a>排序规则：</h5><ul>
<li>执行时间距离当前时间越近，越靠前</li>
<li>如果执行时间相同，则先执行插入时间靠前的任务。</li>
</ul>
<h5 id="新增-获取任务"><a href="#新增-获取任务" class="headerlink" title="新增/获取任务"></a>新增/获取任务</h5><p>  DelayedWorkQueue通过put或者add来新增一条任务，但其底层都是调用offer来新增任务的。对于获取任务，我们知道在ThreadPoolExecutor中线程根据getTask来获取任务队列中的任务，而在getTask中任务队列通过poll或者take函数来获取任务队列中的任务，由于ScheduleThreadPoolExecutor继承自ThreadPoolExecutor，因此其底层获取任务方式相同，只需要DelayedWorkQueue提供take及pool方法即可。</p>
<p>  在分析offer、take及poll之前，我们先看下siftUp及siftDown函数。</p>
<p>  DelayWorkQueue底层是用最小堆数据结构实现的，需要最先执行的任务在堆的顶部，因此在每次插入或者删除任务时需要调整二叉树节点的顺序，但不同于最小堆的地方在于DelayWorkQueue不关心兄弟节点之间的顺序，只要父节点的任务先于子节点执行即可。</p>
<p>  在一个最小堆的队列中，假如索引从0开始，子节点索引值为k，父节点索引值为p，则存在如下规律：</p>
<ol>
<li>一个节点的左子节点的索引为：k = p * 2 + 1；</li>
<li>一个节点的右子节点的索引为：k = (p + 1) * 2；</li>
<li>一个节点的父节点的索引为：p = (k - 1) / 2。</li>
</ol>
<p>  siftUp函数在新增一个任务时调用，通过循环对比父子节点任务执行的先后顺序来调整新任务在堆中的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sifts element added at bottom up to its heap-ordered spot.</span></div><div class="line"><span class="comment"> * Call only when holding lock.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;	<span class="comment">//查找到父节点</span></div><div class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];	<span class="comment">//获取父节点任务</span></div><div class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)	<span class="comment">//如果父节点先于该任务执行，则跳出循环</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = e;	<span class="comment">//与父节点交换位置</span></div><div class="line">        setIndex(e, k);</div><div class="line">        k = parent;	<span class="comment">//重新向上追溯父节点</span></div><div class="line">    &#125;</div><div class="line">    queue[k] = key;	</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  siftDown函数是将一个任务从k节点一层一层地最小堆的底层沉淀，能够保证执行完后最小堆中的父节点任务先于子节点执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sifts element added at top down to its heap-ordered spot.</span></div><div class="line"><span class="comment"> * Call only when holding lock.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;</div><div class="line">        setIndex(c, k);</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>  take函数主要是获取任务队列最小堆中的第一个任务，其使用了leader-follower模式，关于leader-follower模式可以参考这篇<a href="http://blog.csdn.net/goldlevi/article/details/7705180" target="_blank" rel="external">博客</a>。</p>
<blockquote>
<p>leader-follower模式中，所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<ul>
<li>获取任务队列堆顶元素，如果为null则进入wail状态，等待offer的signal唤醒</li>
<li>如果堆顶任务执行时间小于当前时间，则返回堆顶任务</li>
<li>如果leader为空，则将当前线程设置为leader，并等待至堆顶任务执行时间</li>
<li>如果leader已存在，则进入wait状态，等待被唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)	<span class="comment">//队列中没有任务，需要等待offer函数唤醒</span></div><div class="line">                available.await();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)	<span class="comment">//到任务的执行时间，执行该任务</span></div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)	<span class="comment">//当leader线程不为null时说明有leader线程在等待第一个任务，其他线程进入wait状态</span></div><div class="line">                    available.await();</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;	<span class="comment">//设置为leader线程</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      <span class="comment">//等待delay时间，</span></div><div class="line">                        available.awaitNanos(delay);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;	<span class="comment">//将leader设置为null并在下一个循环中获取任务</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();	<span class="comment">//唤醒其他线程</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>  poll的功能和take相似，入参多了一个timeout，如果在timeout时间内获取不到任务则直接返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                  	<span class="comment">//等待timeout</span></div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;	<span class="comment">//未获得任务，则返回空</span></div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">              	<span class="comment">//超时时间&lt;延迟时间或者其他线程正在执行任务，则进入等待状态</span></div><div class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      	<span class="comment">//timeLeft = delay-实际等待时间</span></div><div class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</div><div class="line">                      <span class="comment">//计算剩余超时时长</span></div><div class="line">                        nanos -= delay - timeLeft;</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h4><p>  offer是DelayQueue底层往任务列表中新增一个任务的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = size;</div><div class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">            grow();	<span class="comment">//按1.5倍增长</span></div><div class="line">        size = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">            queue[<span class="number">0</span>] = e;</div><div class="line">            setIndex(e, <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            siftUp(i, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</div><div class="line">            leader = <span class="keyword">null</span>;</div><div class="line">            available.signal();	<span class="comment">//唤醒take或者poll中阻塞的一个线程</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="新增任务"><a href="#新增任务" class="headerlink" title="新增任务"></a>新增任务</h3><p>  ScheduledThreadPoolExecutor支持三种新增任务的方式，新增普通延迟任务，新增固定频率执行任务，新增固定频率执行的延迟任务。</p>
<ol>
<li>通过schedule函数直接新增一条延迟任务</li>
<li>通过scheduleAtFixedRate新增一条按固定频率执行的任务</li>
<li>通过scheduleWithFixedDelay新增一条固定频率执行的延迟任务</li>
</ol>
<p>ScheduledThreadPoolExecutor是如何实现定时任务和延迟任务的呢？由上面可知ScheduledThreadPoolExecutor重新封装了task也就是ScheduledFutureTask，而定时和延迟任务的执行就在ScheduledFutureTask的run中完成的。任务下次执行时间:</p>
<ul>
<li><p>非周期循环任务，无下次执行时间</p>
</li>
<li><p>定时周期任务：上次执行时间+延迟时间</p>
</li>
<li><p>延迟周期任务：当前时间+延迟时间</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">//判断是否是定时任务</span></div><div class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</div><div class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</div><div class="line">        cancel(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</div><div class="line">      	<span class="comment">//正常任务，直接执行</span></div><div class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</div><div class="line">      	<span class="comment">//非定时任务，执行完后设置下次执行的时间</span></div><div class="line">        setNextRunTime();</div><div class="line">        reExecutePeriodic(outerTask);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">long</span> p = period;</div><div class="line">  			<span class="comment">//循环任务直接在本次执行时间上加上时间间隔</span></div><div class="line">            <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</div><div class="line">                time += p;</div><div class="line">            <span class="keyword">else</span></div><div class="line">              <span class="comment">//延迟定时任务则将当前时间+延迟时间作为下次执行的时间</span></div><div class="line">                time = triggerTime(-p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> now() +</div><div class="line">            ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ThreadPoolExecutor源码分析]]></title>
      <url>/2017/08/08/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  线程是程序执行的最小单元，合理的使用线程可以充分利用系统资源、提高吞吐率以及加快响应时间。然而在实际应用中，很多线程都是朝生夕死的。而创建和销毁线程又极大的耗费系统资源，因此从jdk1.5开始引入了线程池的概念，用户可以使用Executors静态工厂类来创建各种各样的满足自己的需求的线程池。一般来说最常用的线程池主要有以下三种:</p>
<ul>
<li>ThreadPoolExecutor：基础多任务线程池框架。</li>
<li>ScheduledThreadPoolExecutor：继承自ThreadPoolExecutor，通过实现延时队列实现定时任务</li>
<li>ForkJoinPool(&gt;=jdk1.7)：并行任务框架，利用多核处理器并行执行任务</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>  ThreadPoolExecutor在初始化之前可以根据用户的配置来维护一个线程池来执行用户提交的任务。其核心方法是execute()，用来提交并执行任务(实现了Runnable接口)，同时通过shutDown和shutDownNow来实现对线程池的生命周期的管理。在介绍核心方法之前，我们先介绍一些ThreadPoolExecutor的重要组成变量或类</p>
<h4 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p>  ctl是ThreadPoolExecutor类的核心，其包含了线程池运行状态以及线程池中的线程数，利用AtomicInteger来保证对这个变量的修改是原子性的。如下图所示为ctl结构图</p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor1.png" alt="ctl结构图" title="ctl结构图"></p>
<p>ctl的低29位用来表示线程池中线程的数量，高3位用来表示线程池的运行状态。</p>
<p>线程池的运行状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;	<span class="comment">//29</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">//00011111111111111111111111111111 = 2^29 - 1</span></div><div class="line"><span class="comment">// runState is stored in the high-order bits</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;	<span class="comment">//11100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	<span class="comment">//00000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//00100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01100000000000000000000000000000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;	<span class="comment">//获取线程池状态</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;	<span class="comment">//获取线程池中线程的个数</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;		<span class="comment">//根据线程池状态和线程个数组合称ctrl</span></div></pre></td></tr></table></figure>
<ul>
<li>RUNNING：线程池正常运行，可接受新的任务或者消费队列中的任务</li>
<li>SHUTDOWN：线程池关闭(主线程调用shutdown方法)，不再接受新的任务，但会继续执行队列中的任务</li>
<li>STOP：线程池终止(主线程调用shudownNow方法)，既不接受新的任务也不再执行队列中的任务</li>
<li>TIDYING：所有的任务都被终止，线程数为0，所有线程都被终止。当线程池转换到TIDYING状态时会执行terminated(默认什么都不执行，由子类复写)方法</li>
<li>TERMINATED：TIDYING状态下执行完terminated方法，线程池转化为此状态</li>
</ul>
<p>线程池状态转换图:</p>
<p>​                    <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor2.png" alt="状态转换图" title="状态转换图"></p>
<p>后两种状态相对来说比较复杂，我们这里着重关注前三种状态即可。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  先来看一下构造函数的入参:</p>
<ol>
<li>corePoolSize:线程池核心线程数</li>
<li>maximumPoolSize:线程池最大线程数</li>
<li>keepAliveTime:线程空闲时存活时长，当allowCoreThreadTimeOut=true时，核心线程也会被回收</li>
<li>unit:keepAliveTime的单位</li>
<li>workQueue:任务存储队列，主要有以下几种队列<ul>
<li>LinkedBlockingQueue:无界的FIFO队列(maximumPoolSize失效)</li>
<li>ArrayBlockingQueue:有界FIFO队列</li>
<li>SynchronousQueue:不存储元素的阻塞队列，插入操作必须等待移除操作完成后才能执行</li>
<li>ProorityBlockingQueue:具有优先级的无界阻塞队列</li>
</ul>
</li>
<li>threadFactory:创建线程的工厂类(默认为DefaultThreadFactory)</li>
<li>handler:线程池不能接受新线程时拒绝策略,默认有以下几种策略<ul>
<li>AbortPolicy:直接抛异常（默认）</li>
<li>CallerRunsPolicy:由创建线程池的线程执行当前提交的任务</li>
<li>DiscardOldestPolicy:抛弃队列头的任务</li>
<li>DiscardPolicy:直接抛弃</li>
</ul>
</li>
</ol>
<p>线程池的上面的几个参数决定了线程创建策略以及任务执行过程，如下图所示为一个任务提交执行的流程:</p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor3.png" alt="任务提交流程图" title="任务提交流程图"></p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor4.png" alt="任务提交流程图" title="任务提交流程图"></p>
<h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>  Worker是线程池中线程的基本单位，其对线程进行了一个简单的包装，本身实现了Runnable接口。同时Worker继承自AbstractQueuedSynchronizer(<a href="http://ifeve.com/java-special-troops-aqs/" target="_blank" rel="external">AQS</a>)，实现了一份简单的非重入互斥锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">      <span class="comment">/** worker运行的线程 */</span></div><div class="line">        <span class="keyword">final</span> Thread thread;</div><div class="line">        <span class="comment">/** 初始化时提交的任务，可能为null*/</span></div><div class="line">        Runnable firstTask;</div><div class="line">        <span class="comment">/** workder完成的任务数*/</span></div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</div><div class="line">  		...</div><div class="line">        </div><div class="line">        <span class="comment">//加锁</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">            setState(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor重要方法"><a href="#ThreadPoolExecutor重要方法" class="headerlink" title="ThreadPoolExecutor重要方法"></a>ThreadPoolExecutor重要方法</h3><h4 id="execute-Runnable-command-提交任务"><a href="#execute-Runnable-command-提交任务" class="headerlink" title="execute(Runnable command)提交任务"></a>execute(Runnable command)提交任务</h4><p>  execute方法用于用户提交任务，线程池对任务有三种处理方式:新建一个线程执行任务、放入queue队列或者拒绝任务执行。由于execute方法执行的时候并未加锁，因此会在多个地方进行double check线程池的状态。</p>
<ul>
<li>尝试增加核心线程(step1)</li>
<li>尝试将任务放入任务队列(step2)</li>
<li>尝试增加非核心线程(step3)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;    </div><div class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Proceed in 3 steps:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></div><div class="line"><span class="comment">     * start a new thread with the given command as its first</span></div><div class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></div><div class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></div><div class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></div><div class="line"><span class="comment">     * to double-check whether we should have added a thread</span></div><div class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></div><div class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></div><div class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></div><div class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></div><div class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></div><div class="line"><span class="comment">     * and so reject the task.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">// 线程池中线程数小于核心线程数(step1)</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();  <span class="comment">//如果增加线程失败，说明线程池状态发生变化，需要重新获取线程池状态</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程池正常，将任务放进队列中(step2)</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">//需要进行double check，防止在执行该方法时线程状态变化</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//如果线程处于非运行状态则需要移除该任务，并调用拒绝策略拒绝任务</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="comment">//线程池中线程数为0说明在执行该方法时主线程执行了shutdown操作，需要重新启动一个线程执行队列中的任务(由于workQueue.offer(command)执行成功，因此队列中至少有一个任务)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))	<span class="comment">//增加非核心线程(step3)</span></div><div class="line">        reject(command);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="addWorker-Runnable-firstTask-boolean-core-新增线程，并处理当前任务"><a href="#addWorker-Runnable-firstTask-boolean-core-新增线程，并处理当前任务" class="headerlink" title="addWorker(Runnable firstTask, boolean core) 新增线程，并处理当前任务"></a>addWorker(Runnable firstTask, boolean core) 新增线程，并处理当前任务</h4><ul>
<li>firstTask:创建线程时当前需要执行的任务</li>
<li>core:创建的线程是否是核心线程(true:核心线程,false:非核心线程)</li>
</ul>
<p>新增Worker主要有以下三个步骤:</p>
<ul>
<li>线程池状态检查：非RUNNING和SHUTDOWN状态下线程池拒绝创建新线程并拒绝提交任务，SHUTDOWN状态下不允许提交新任务，但在线程池中线程数为0并且任务队列不为空时才允许创建一个线程来执行任务队列中剩余的任务。</li>
<li>线程池中线程数量检查：线程池线程数量 &gt;= CAPACITY || 核心线程数 &gt;= corePoolSize || 总线程数  &gt;= maximumPoolSize 不允许创建线程；</li>
<li>创建新线程并将其加到线程池中，同时调用start()启动线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">/*******************  1. 状态检查begin   *****************************/</span></div><div class="line"></div><div class="line">        <span class="comment">//等同于 rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></div><div class="line">        <span class="comment">//等同于 </span></div><div class="line">        <span class="comment">// 1. rs &gt; SHUTDOWN：不允许新增线程，不接受新任务</span></div><div class="line">        <span class="comment">// 2. rs = SHUTDOWN &amp;&amp; firstTask != null：不允许新增线程，并拒绝新任务</span></div><div class="line">        <span class="comment">// 3. rs = SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty(): 线程池关闭，任务队列中的任务为空，不再允许提交新的任务</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*******************  状态检查end     *****************************/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*******************  2. 线程池数量检查begin     *****************************/</span></div><div class="line">      	<span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">//1. 线程数 &gt;= CAPACITY</span></div><div class="line">          	<span class="comment">//2. 线程数 &gt;= corePoolSize时不允许创建核心线程</span></div><div class="line">          	<span class="comment">//3. 线程数  &gt;= maximumPoolSize 不允许创建非核心线程</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//增加线程数成功，跳出retry循环</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">//re-check线程池状态，不一致说明触发了线程池状态变更，需要重新验证是否需要创建新的线程</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">/*******************  线程池数量检查end     *****************************/</span></div><div class="line"></div><div class="line">  	<span class="comment">/*******************  3.创建并运行线程begin     *****************************/</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Recheck while holding lock.</span></div><div class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line">                <span class="comment">// shut down before lock acquired.</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// 1. 线程池处于正常运行时，新增线程ok</span></div><div class="line">                <span class="comment">// 2. rs = SHUTDOWN状态下，只有firstTask为null时才允许新增线程,见execute(),线程池关闭并且线程数为0</span></div><div class="line">                <span class="comment">//但任务队列中还有未完成的任务.</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                t.start();  <span class="comment">//启动线程</span></div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">    <span class="comment">/*******************  3.创建并运行线程end     *****************************/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Worker-run"><a href="#Worker-run" class="headerlink" title="Worker.run()"></a>Worker.run()</h4><p>  由于Worker本身实现了Runable接口，因此主线程在addWorker中调用t.start()方法后就启动了线程。而Worker的run中又调用了ThreadPoolExecutor的runWorker方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor-runWorker-Worker-worker"><a href="#ThreadPoolExecutor-runWorker-Worker-worker" class="headerlink" title="ThreadPoolExecutor.runWorker(Worker worker)"></a>ThreadPoolExecutor.runWorker(Worker worker)</h4><p>  runWorker是线程池中线程运行的核心，通过一个while的loop循环来保证线程运行状态，首先会处理初始化Worker的任务，如果初始化任务为空则会从任务队列中获取任务进行执行。</p>
<ul>
<li>获取需要执行的任务，初始化任务或者从任务队列中获取的任务</li>
<li>检查线程池状态，保证线程池能够及时中断</li>
<li>beforeExecute—&gt;task.run()—&gt;afterExecute</li>
<li>退出while循环后，执行processWorkerExit方法，中断一个空闲线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">   	Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;    <span class="comment">//先执行初始化时的任务</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">//主要用来判断线程是正常结束还是异常结束，true为异常结束，在processWorkerExit中用来标志是否将线程池中的线程数减一</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></div><div class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></div><div class="line">            <span class="comment">// requires a recheck in second case to deal with</span></div><div class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></div><div class="line">          	<span class="comment">//判断线程池状态，中断线程</span></div><div class="line">          	<span class="comment">// 线程池状态&gt;=STOP并且线程未被中断，需要中断线程</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//执行自定义的任务执行前操作，默认什么也不执行</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//执行任务</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                  	<span class="comment">//任务执行后执行的操作，默认什么也不执行</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      	<span class="comment">//线程退出后执行清理工作</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h4><p>  getTask主要有两个个功能，获取任务队列中的任务并判断是否需要回收线程(返回null则说明需要回收线程)。</p>
<ul>
<li>例行检查线程池状态</li>
<li>根据timed(是否需要回收线程)和timeOut(线程空闲时间是否超过keepAlive)等来判断是否回收线程</li>
<li>如果需要回收线程，则利用任务队列的poll机制来设定线程空闲时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回null则退出线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">      	<span class="comment">// 1. rs &gt; SHUTDOWN：线程池关闭，回收该线程</span></div><div class="line">      	<span class="comment">// 2. rs = SHUTDOWN &amp;&amp; workQueue.isEmpty():任务队列中任务执行完毕，回收该线程</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// timed表示是否需要回收该线程，如果allowCoreThreadTimeOut设置为true则无论当前线程数</span></div><div class="line">        <span class="comment">// 设置多少都需要回收，否则只有当线程池中线程数大于corePoolSize时才需要回收</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        <span class="comment">//需要回收线程时，则将线程数减一，并返回null，在runWorker中回收线程</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            <span class="comment">//1：如果timed为true，该线程需要回收，通过将workQueue.poll的超时时间设置为</span></div><div class="line">            <span class="comment">// keepAliveTime来保证返回的task是否为空，从而来判断该线程是否需要回收</span></div><div class="line">            <span class="comment">// 2：timed为false，则阻塞获取workQueue，直到线程中断或者获取到任务</span></div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><p>  processWorkerExit主要是在线程结束后做一些处理工作</p>
<ul>
<li>如果线程异常结束则原子递减线程池中的线程数，同时移除线程池中的线程</li>
<li>尝试中断线程池，主要是进行例行检查</li>
<li>检查线程池状态，并根据线程池配置或者当前线程是否是正常结束来判断是否回补线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (completedAbruptly) <span class="comment">// 如果线程时异常退出，需要将线程数减一，正常线程数递减是在getTask()中进行的</span></div><div class="line">        decrementWorkerCount();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        completedTaskCount += w.completedTasks;</div><div class="line">        workers.remove(w);  <span class="comment">//移除线程</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tryTerminate();     <span class="comment">//尝试中断线程池，在执行过程中shutDown()或者shutDownNow()可能被调用</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line"></div><div class="line">    <span class="comment">//线程处于RUNNINg和SHUTDOWN状态时，需要进一步处理线程</span></div><div class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//线程正常结束</span></div><div class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</div><div class="line">            <span class="comment">//如果允许核心线程回收，那么min就位0，否则为核心线程数</span></div><div class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</div><div class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                min = <span class="number">1</span>;</div><div class="line">            <span class="comment">//当前线程池线程数大于min则没有什么问题</span></div><div class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</div><div class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//线程异常结束,需要回补该异常结束的线程</span></div><div class="line">        <span class="comment">//线程数为0但线程池处于SHUTDOWN状态或者非核心线程也被回收了，则需要创建一个线程执行任务队列中的任务</span></div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWriteArrayList源码分析]]></title>
      <url>/2017/08/08/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><pre><code>CopyOnWriteArrayList是一个在多线程操作中线程安全的ArrayList的一个变种，她在所有对ArrayList对象的编辑操作(add,set等)都会复制一份副本，因此无论是对ArrayList操作还是对其iterator操作都不会抛ConcurrentModificationException异常。
</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　CopyOnWriteArrayList通常适用于读多写少的场景，对每次写操作都会复制一份数据的副本，因此不会影响原先数据的读操作。虽然每次复制副本会耗费时间，但相对于使用synchronize来保证线程安全，在特定场景下效果还是不错的。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code>/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;

/**
 * Gets the array.  Non-private so as to also be accessible
 * from CopyOnWriteArraySet class.
 */
final Object[] getArray() {
    return array;
}

/**
 * Sets the array.
 */
final void setArray(Object[] a) {
    array = a;
}
</code></pre><p>　　CopyOnWriteArrayList维护一个ReentrantLock锁，主要用于保证同一时间只能有一个线程对array数据进行复制编辑操作(set,add等)，避免多线程下对数据复制操作造成数据不一致现象。 同时array声明为volatile，保证线程读取数据时将内存的数据刷新至缓存，从而得到最新数据。写入数据时保证最新数据写入到内存。在CopyOnWriteArrayList所有操作中，获取数据和写入数据不是直接使用this.array=array，而是使用getArray()和setArray()操作，刷新一下缓存，保证获得的是最新数据及将最新数据写入内存。</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}

/**
 * {@inheritDoc}
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    return get(getArray(), index);
}
</code></pre><p>　　CopyOnWriteArrayList所有的读操作都是线程安全的，因为每次读操作读的都是元数据的一个snapshot。同时由getArray()来保证读到的数据都是最新版本的。</p>
<pre><code>/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

/**
 * Removes the element at the specified position in this list.
 * Shifts any subsequent elements to the left (subtracts one from their
 * indices).  Returns the element that was removed from the list.
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>　　再看一下编辑操作,这里以add()和remove()为例，可以看到每次只能有一个线程可以对ArrayList进行修改，而在修改之前通过getArray()来保证获取最新的array数据，然后复制一份array的副本newElements(复制过程根据具体操作而定,例如add会全部复制并预留一个位置，而remove则部分复制)，对副本进行编辑后再通过setArray将最新的副本赋给array。这样其他线程再进行读操作时通过getArray()获取的就是最近编辑过的数据。</p>
<h3 id="COWIterator"><a href="#COWIterator" class="headerlink" title="COWIterator"></a>COWIterator</h3><p>　　传统的ListIterator在遍历列表时如果列表被修改会有fast-fail机制来保证线程安全，而于CopyOnWriteArrayList已经具备线程安全性，并且CopyOnWriteArrayList的Iterator更多的用于数据的遍历，所以其关闭了iterator对数据的编辑功能.</p>
<p>/**</p>
<pre><code>     * Not supported. Always throws UnsupportedOperationException.
     * @throws UnsupportedOperationException always; {@code remove}
     *         is not supported by this iterator.
     */
    public void remove() {
        throw new UnsupportedOperationException();
    }


/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code set}
 *         is not supported by this iterator.
 */
public void set(E e) {
    throw new UnsupportedOperationException();
}

/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code add}
 *         is not supported by this iterator.
 */
public void add(E e) {
    throw new UnsupportedOperationException();
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  CopyOnWriteArrayList通过编辑操作复制元数据副本的方式成功避免了多线程操作List线程不安全的问题，同时通过声明array[]为volitile类型保证线程每次读取的数据都是最新数据。<br>  由于每次编辑操作都会复制一份副本，因此CopyOnWriteArrayList只适用于读多改少的场景，在其他场景中还是建议使用synchronize或者Collections.SynchronizedList来保证线程安全<br>  CopyOnWriteArrayList不能保证线程遍历的数据一定是最新的数据，因此是能适用于实时性要求不高的场景。</p>
]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String源码分析]]></title>
      <url>/2017/08/08/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>  String类内部维护了一个char[]类型的value用来存储字符串，相对来说源码较为简单些。</p>
<h3 id="1-不可变性"><a href="#1-不可变性" class="headerlink" title="1.不可变性"></a>1.不可变性</h3><p>String的不可变主要体现在三个方面:</p>
<ul>
<li>String类被定义为final类型，不可被继承</li>
<li>String中的value[]被定义为final</li>
<li>String中的所有生成新的String的操作底层都调用Array.copy或者System.copy来生成一个新的String对象</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>  String的有多个构造函数，但以下几个较为特殊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = original.value;</div><div class="line">    <span class="keyword">this</span>.hash = original.hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</div><div class="line">    <span class="comment">// assert share : "unshared not supported";</span></div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  以上两个是较为特殊的一类构造函数，第一个用一个现成的String来初始化一个新的String对象，构造方法直接将新的String对象的value指向老的value对象。由于String是不可变的，所以这里不需要重新copy一份value的对象。第二个构造方法看似会破坏String类型的不可变性(当参数value变化时String也会变化)，但该构造方法并没有声明为public，只允许在包内使用，被声明为public的String(char value[])底层调用的是Array.copy来实现底层数据拷贝的，上述的两个构造函数已经不建议使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></div><div class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上面这个构造函数较为典型，很多其他的构造函数都与其类似或者底层调用了该构造函数，入参是一个char数组(byte[])，offset偏移位置及count偏移量。底层调用Arrays.copy函数来进行深度复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(buffer) &#123;  <span class="comment">//保证线程安全</span></div><div class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上述两个构造函数入参分别是StringBuffer和StringBuilder，底层都是调用Arrays.copyOf，唯一不同的是StringBuffer是线程不安全的，所有调用时需要用synchronized关键字。</p>
<h3 id="3-其他方法"><a href="#3-其他方法" class="headerlink" title="3.其他方法"></a>3.其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> fromIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</div><div class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        fromIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> first = target[targetOffset];</div><div class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        <span class="comment">/* Look for first character. */</span></div><div class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</div><div class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></div><div class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</div><div class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</div><div class="line">                    == target[k]; j++, k++);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == end) &#123;</div><div class="line">                <span class="comment">/* Found whole string. */</span></div><div class="line">                <span class="keyword">return</span> i - sourceOffset;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> fromIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Check arguments; return immediately where possible. For</span></div><div class="line"><span class="comment">     * consistency, don't check for null str.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</div><div class="line">        fromIndex = rightIndex;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Empty string always matches. */</span></div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> strLastChar = target[strLastIndex];</div><div class="line">    <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = min + fromIndex;</div><div class="line"></div><div class="line">    startSearchForLastChar:</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; min) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &gt; start) &#123;</div><div class="line">            <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</div><div class="line">                i--;</div><div class="line">                <span class="keyword">continue</span> startSearchForLastChar;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  indexOf和lastIndexOf主要是index和lastIndex函数的底层调用，通读代码会发现底层实现并没有特别牛逼的kmp算法，仍然是一个字符一个字符扫描实现的。其中lastIndexOf还是用了continue startSearchForLastChar;相对来说比较少见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</div><div class="line">        <span class="keyword">int</span> len = value.length;</div><div class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果找不到则返回this</span></div><div class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</div><div class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                buf[j] = val[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">                <span class="keyword">char</span> c = val[i]; <span class="comment">//替换</span></div><div class="line">                buf[i] = (c == oldChar) ? newChar : c;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回新的String,利用上述包内的非public构造函数</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  replace用于将String对象中的一个字符替换为另一个字符，如果找不到制定的字符则返回本身，如果找到则会另建一个新的String对象返回。</p>
]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
