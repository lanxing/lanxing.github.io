<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Netty In Action(二)]]></title>
      <url>/2017/09/13/Netty-In-Action-%E4%BA%8C/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Netty in Action(一)]]></title>
      <url>/2017/09/11/Netty-in-Action-%E4%B8%80/</url>
      <content type="html"><![CDATA[<h3 id="netty是什么"><a href="#netty是什么" class="headerlink" title="netty是什么"></a>netty是什么</h3><p>&emsp; &emsp; Nettt是一个基于Java NIO的client-server网络服务框架，人们可以利用netty快速地开发网络应用。同时netty相对于其他网络框架更加简单并且扩展性更强，这主要得益于其提供的简单易用的api将业务逻辑和网络处理代码解耦开来。能够使你更加专注于业务的实现而不需要太多关心网络底层实现。</p>
<h3 id="异步设计"><a href="#异步设计" class="headerlink" title="异步设计"></a>异步设计</h3><p>&emsp; &emsp; netty所有的api都是异步的。异步处理已经不是什么新鲜事了，众所周知，IO已经变为一个应用的瓶颈，而异步处理正是为了解决这个问题出现的。</p>
<h4 id="CallBacks机制"><a href="#CallBacks机制" class="headerlink" title="CallBacks机制"></a>CallBacks机制</h4><p>&emsp; &emsp; CallBacks机制经常应用于异步处理，人们可以指定方法执行完后的回调函数，在JavaScript中，回调机制是其语言的核心。下面代码展示了如何利用回调机制处理接受数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Fetcher</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">fetchData</span><span class="params">(FetchCallback callback)</span></span>;</div><div class="line">&#125;</div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FetchCallback</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onData</span><span class="params">(Data data)</span></span>;</div><div class="line">       <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable cause)</span></span>;</div><div class="line">&#125;</div><div class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">         Fetcher fetcher = ...</div><div class="line">           fetcher.fetchData(<span class="keyword">new</span> FetchCallback() &#123;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               public void onData(Data data) &#123;                             #1</div><div class="line">                   System.out.println(<span class="string">"Data received: "</span> + data);</div><div class="line">               &#125;</div><div class="line">               <span class="meta">@Override</span></div><div class="line">               public void onError(Throwable cause) &#123;                      #2</div><div class="line">                   System.err.println(<span class="string">"An error accour: "</span> + cause.getMessage());</div><div class="line">               &#125;</div><div class="line">&#125;);</div><div class="line">... &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#1 没有出现错误，调用onData</p>
<p>#2 出现错误信息，调用onError</p>
<p>&emsp; &emsp; 你可以将回调函数从当前线程移植到其他线程，但是并不能保证回调函数被执行。当你将多个异步回调函数串起来的时候会形成spaghetti code(管式代码)，有些人认为这样的代码很难读，但JavaScript以及Node.js都是这种风格。</p>
<h4 id="Futures机制"><a href="#Futures机制" class="headerlink" title="Futures机制"></a>Futures机制</h4><p>&emsp; &emsp; 异步处理使用的第二个机制是Future机制。一个Future对象只有在特定情况下才会有值，Future对象要么是调用者的返回结果，要么是一个异常。Java在java.util.concurrent包中提供了供其线程池机制使用的Future接口，例如当你使用ExecutorService.submit()提交一个Runable任务时，就可以返回一个Future对象，利用Future对象可以判断该任务是否完成。如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line">   Runnable task1 = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">           doSomeHeavyWork();</div><div class="line">       &#125;</div><div class="line">... &#125;</div><div class="line">   Callable&lt;Interger&gt; task2 = <span class="keyword">new</span> Callable() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">           <span class="keyword">return</span> doSomeHeavyWorkWithResul();</div><div class="line">       &#125;</div><div class="line">... &#125;</div><div class="line">   Future&lt;?&gt; future1 = executor.submit(task1);</div><div class="line">   Future&lt;Integer&gt; future2 = executor.submit(task2);</div><div class="line">   <span class="keyword">while</span> (!future1.isDone() || !future2.isDone()) &#123;</div><div class="line">       ...</div><div class="line">       <span class="comment">// do something else</span></div><div class="line">       ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; CallBacks和Future是异步处理中最常用的两种机制，实际上无法判断两种机制的优劣，而Netty则会两种都提供，你可以自由选择使用哪种机制。</p>
<h3 id="JVM中的阻塞与非阻塞比较"><a href="#JVM中的阻塞与非阻塞比较" class="headerlink" title="JVM中的阻塞与非阻塞比较"></a>JVM中的阻塞与非阻塞比较</h3><p>&emsp; &emsp; 随着web应用的持续增长，如何提升网络应用的效率变得尤为重要。幸运的是从1.4版本开始，java提供了NIO API来供我们编写更有效率的网络应用。Java 7中又引入的NIO.2不仅仅是之前api的升级，同时也允许我们更加高效方便地编写异步代码。</p>
<blockquote>
<p>New or non-blocking?</p>
<p>The N in NIO is typically thought to mean non-blocking rather than new.NIO has beenaround for so long now that nobody calls it new IO anymore. Most people refer to it as non-blocking IO</p>
</blockquote>
<p>​                        <img src="/2017/09/11/Netty-in-Action-一/img1.png" alt="阻塞IO" title="阻塞IO"></p>
<p>&emsp; &emsp; 上图所示为典型的阻塞IO模式，一个线程处理一个网络连接，因此应用能够处理连接的个数是由JVM上允许建立的线程个数决定的。</p>
<p>​                        <img src="/2017/09/11/Netty-in-Action-一/img2.png" alt="非阻塞IO" title="非阻塞IO"><br>&emsp; &emsp; 再来看下非阻塞IO模式，上图运用selector机制来处理多个连接。下面通过一个回显服务器示例来讲解非阻塞及阻塞IO的区别。</p>
<h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainEchoServer</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">            final ServerSocket socket = new ServerSocket(port);              #1</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                    final Socket clientSocket = socket.accept();             #2</div><div class="line">                    System.out.println(<span class="string">"Accepted connection from "</span> +</div><div class="line">                            clientSocket);</div><div class="line">                    new Thread(new Runnable() &#123;                              #3</div><div class="line"></div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                BufferedReader reader = <span class="keyword">new</span> BufferedReader(</div><div class="line">                                        <span class="keyword">new</span></div><div class="line">                                                InputStreamReader(clientSocket.getInputStream()));</div><div class="line">                                PrintWriter writer = <span class="keyword">new</span> PrintWriter(clientSocket</div><div class="line">                                        .getOutputStream(), <span class="keyword">true</span>);</div><div class="line">                                while (true) &#123;                                #4</div><div class="line">                                    writer.println(reader.readLine());</div><div class="line">                                    writer.flush();</div><div class="line">                                &#125;</div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                                <span class="keyword">try</span> &#123;</div><div class="line">                                    clientSocket.close();</div><div class="line">                                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                                    <span class="comment">// ignore on close</span></div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;).start();                                              #5</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p># 1 绑定监听端口</p>
<p># 2 阻塞至有新连接进来</p>
<p># 3 新建线程用来处理客户端连接</p>
<p># 4 从客户端读取数据并回写</p>
<p># 5 启动线程</p>
<p>&emsp; &emsp; 上述服务器代码要求每次连接进来一个请求就需要创建一个新的线程，即使使用线程池也仅能解决一时问题，不能再根本上解决问题：客户端的连接数取决于后台处理线程的个数。当连接数多时则会带来大问题。</p>
<h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>&emsp; &emsp; 在介绍NIO之前，我们先了解一些NIO的基本知识</p>
<h5 id="BYTEBUFFER"><a href="#BYTEBUFFER" class="headerlink" title="BYTEBUFFER"></a>BYTEBUFFER</h5><p>&emsp; &emsp; ByteBuffer在Netty中即为重要，其主要是用来缓存数据的。ByteBuffer既可以分配到堆内存中也可以分配到堆外内存。一般来说，堆外内存能够更加快速地传递给channel，但分配和释放会更耗时。新旧的NIO API对ByteBuffer提供了统一的管理。ByteBuffer能够实现无拷贝地在各个实例之间共享，同时允许对可见数据进行切片和其他操作处理。</p>
<blockquote>
<p>Slicing</p>
<p>Slicing a ByteBuffer allows to create a new ByteBuffer that share the same data as the intialByteBuffer but only expose a sub-region of it. This is useful to minimize memory copies whilestill only allow access to a part of the data</p>
</blockquote>
<p>ByteBuffer有以下几个重要的操作</p>
<ul>
<li>将数据写进ByteBuffer</li>
<li>调用ByteBuffer.flip()切换到读模式</li>
<li>从ByteBuffer中读取数据</li>
<li>调用ByteBuffer.clear()或者ByteBuffer.compact()来整理ByteBuffer内存</li>
</ul>
<p>&emsp; &emsp; 当往ByteBuffer中写数据时，ByteBuffer会通过更新buffer中write index的位置来跟踪buffer中的数据(也可以手动更新)。当需要从ByteBuffer中读取数据时，需要调用flip()来切换到读模式，flip()会将buffer的读起始位置设置为0，这样就可以读取buffer中所有数据了。</p>
<p>&emsp; &emsp; 为了能够再次向ByteBuffer中写数据，可以将buffer模式切换到写模式并调用任意下列两个方法。</p>
<ul>
<li>ByteBuffer.clear()：清除ByteBuffer</li>
<li>ByteBuffer.compact()：通过内存拷贝清除已经读过的数据</li>
</ul>
<p>&emsp; &emsp; ByteBuffer.compact()会将所有未读的数据拷贝到buffer的起始位置。如下所示为ByteBuffer的使用示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Channel inChannel = ....;</div><div class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</div><div class="line"><span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">    bytesRead = inChannel.read(buf);			#1</div><div class="line">    <span class="keyword">if</span> (bytesRead != -<span class="number">1</span>) &#123;</div><div class="line">    buf.flip();									#2</div><div class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</div><div class="line">        System.out.print((char) buf.get());		#3</div><div class="line">    &#125;</div><div class="line">    buf.clear();								#4</div><div class="line">    &#125;</div><div class="line">&#125; <span class="keyword">while</span> (bytesRead != -<span class="number">1</span>);</div><div class="line">inChannel.close();</div></pre></td></tr></table></figure>
<p>#1 从channel中读取数据到ByteBuffer</p>
<p>#2 切换模式至读模式</p>
<p>#3 读取buffer中的数据，每次调用一个get()会将buffer当前位置更新+1</p>
<p>#4 切换buffer至写模式，使其可以重新写</p>
<h5 id="使用Selector模式"><a href="#使用Selector模式" class="headerlink" title="使用Selector模式"></a>使用Selector模式</h5><p>&emsp; &emsp; Selector可以监听多个IO是否可以读/写，这样一个Selector就可以用来处理多个连接，相比于阻塞IO每个连接占用一个线程，Selector模式更加高效。</p>
<p>通过以下几个操作就可以轻松运用Selector</p>
<ol>
<li>在channels上创建一个或多个Selector</li>
<li>在channel上注册需要监听的事件，目前支持四种事件<ul>
<li>OP_ACCEPT：socket-accept事件</li>
<li>OP_CONNECT：socket-connect事件</li>
<li>OP_READ：可读事件</li>
<li>OP_WRITE：可写事件</li>
</ul>
</li>
<li>channel注册后，调用Selector.select()方法阻塞直到上述注册的一个事件发生</li>
<li>当Selector.select()返回时，可以通过SelectionKey实例获取所有可操作的事件</li>
</ol>
<p>&emsp; &emsp; 下面EchoServer是基于非阻塞Selector的服务器代码，运用这个版本的Server可以运用一个线程处理上千个连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNioEchoServer</span> </span>&#123;</div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">           System.out.println(<span class="string">"Listening for connections on port "</span> + port);</div><div class="line"> ServerSocketChannel serverChannel = ServerSocketChannel.open();</div><div class="line">        ServerSocket ss = serverChannel.socket();</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">        ss.bind(address);                                                #1</div><div class="line">        serverChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line">Selector  selector = Selector.open();</div><div class="line">        serverChannel.register(selector, SelectionKey.OP_ACCEPT);        #2</div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                selector.select();                                       #3</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                ex.printStackTrace();</div><div class="line">                <span class="comment">// handle in a proper way</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">&#125;</div><div class="line">            Set readyKeys = selector.selectedKeys();                     #4</div><div class="line">            Iterator iterator = readyKeys.iterator();</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                SelectionKey key = (SelectionKey) iterator.next();</div><div class="line">                iterator.remove();                                       #5</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</div><div class="line">                      ServerSocketChannel server = (ServerSocketChannel)key.channel();</div><div class="line">                      SocketChannel client = server.accept();			#6</div><div class="line">                      System.out.println(<span class="string">"Accepted connection from"</span> + client);</div><div class="line">                      client.configureBlocking(<span class="keyword">false</span>);</div><div class="line">                      client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, ByteBuffer.allocate(100));                         					  #7</div><div class="line">                    &#125;</div><div class="line">                    if (key.isReadable()) &#123;                              #8</div><div class="line">                        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</div><div class="line">                        client.read(output);                             #9</div><div class="line">                    &#125;</div><div class="line">                    if (key.isWritable()) &#123;                             #10</div><div class="line">                        SocketChannel client = (SocketChannel) key.channel();</div><div class="line">                        ByteBuffer output = (ByteBuffer) key.attachment();</div><div class="line">                        output.flip();</div><div class="line">                        client.write(output);                           #11</div><div class="line">                        output.compact();</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">                    key.cancel();</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        key.channel().close();</div><div class="line">                    &#125; <span class="keyword">catch</span> (IOException cex) &#123;</div><div class="line">                   &#125;</div><div class="line">				&#125; </div><div class="line">            &#125;</div><div class="line">		&#125; </div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#1 绑定Server的port</p>
<p>#2 注册channel的OP_ACCEPT Selector事件，监听新连接</p>
<p>#3 阻塞直到有新的连接事件到来</p>
<p>#4 获取所有可操作的SelectedKey实例</p>
<p>#5 遍历SelectedKey实例，将遍历过的去除</p>
<p>#6 获取新的连接</p>
<p>#7 将新的连接注册到Selector中，并监听读/写事件</p>
<p>#8 检查SelectKey是否可读</p>
<p>#9 读数据</p>
<p>#10 检测是否可写</p>
<p>#11 写数据</p>
<p>&emsp; &emsp; 上述代码实现起来比较繁琐，新的NIO API去掉了大部分繁琐的过程，使实现起来更加简单明了</p>
<h4 id="基于NIO-2的EchoServer"><a href="#基于NIO-2的EchoServer" class="headerlink" title="基于NIO.2的EchoServer"></a>基于NIO.2的EchoServer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlainNio2EchoServer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serve</span><span class="params">(<span class="keyword">int</span> port)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Listening for connections on port "</span> + port);</div><div class="line">        <span class="keyword">final</span> AsynchronousServerSocketChannel serverChannel =</div><div class="line">                AsynchronousServerSocketChannel.open();</div><div class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(port);</div><div class="line">        serverChannel.bind(address);                                    #1</div><div class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</div><div class="line">        serverChannel.accept(<span class="keyword">null</span>, <span class="keyword">new</span></div><div class="line">                CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;                #2</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(<span class="keyword">final</span> AsynchronousSocketChannel channel, Object attachment)</span> </span>&#123;</div><div class="line">                        serverChannel.accept(null, this);                       #3</div><div class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</div><div class="line">                        channel.read(buffer, buffer,</div><div class="line">                                new EchoCompletionHandler(channel));            #4</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span> <span class="params">(Throwable throwable, Object attachment)</span></span>&#123;</div><div class="line">                            <span class="keyword">try</span> &#123;</div><div class="line">                                serverChannel.close();                              #5</div><div class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                                <span class="comment">// ingnore on close</span></div><div class="line">                            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                                latch.countDown();</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;); <span class="keyword">try</span></div><div class="line"></div><div class="line">                    &#123;</div><div class="line">                        latch.await();</div><div class="line">                    &#125; <span class="keyword">catch</span>(</div><div class="line">                    InterruptedException e)</div><div class="line"></div><div class="line">                    &#123;</div><div class="line">                        Thread.currentThread().interrupt();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoCompletionHandler</span> <span class="keyword">implements</span></span></div><div class="line"><span class="class">                <span class="title">CompletionHandler</span>&lt;<span class="title">Integer</span>, <span class="title">ByteBuffer</span>&gt; </span>&#123;</div><div class="line">            <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel channel;</div><div class="line"></div><div class="line">            EchoCompletionHandler(AsynchronousSocketChannel channel) &#123;</div><div class="line">                <span class="keyword">this</span>.channel = channel;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</div><div class="line">                buffer.flip();</div><div class="line">                channel.write(buffer, buffer, new CompletionHandler&lt;Integer,    #6</div><div class="line">                        ByteBuffer&gt;() &#123;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer buffer)</span> </span>&#123;</div><div class="line">                        <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</div><div class="line">                            channel.write(buffer, buffer, this);            #7</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            buffer.compact();</div><div class="line">                            channel.read(buffer, buffer,</div><div class="line">                                    EchoCompletionHandler.this);             #8</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            channel.close();</div><div class="line">                        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                            <span class="comment">// ingnore on close</span></div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    channel.close();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    <span class="comment">// ingnore on close</span></div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>#1 绑定Server的port</p>
<p>#2 监听新连接到来，一旦有新的连接接入则会调用CompletionHandler</p>
<p>#3 重新监听连接接入事件</p>
<p>#4 在channel上触发读操作，一单有数据可读EchoCompletionHandler将会被触发</p>
<p>#5 出现错误时关闭channel</p>
<p>#6 注册写回调事件，通#4</p>
<p>#7 当buffer中还有数据时再次注册写事件</p>
<p>#8 同#4，注册CompletionHandler回调读事件</p>
<p>&emsp; &emsp; 上述代码看起来要比之前的更加复杂，按NIO2.0自己实现了loop事件，我们在使用的时候只需要简单地注册自己感兴趣的事件即可。</p>
<h3 id="非阻塞应用存在的问题以及Netty是如何解决的"><a href="#非阻塞应用存在的问题以及Netty是如何解决的" class="headerlink" title="非阻塞应用存在的问题以及Netty是如何解决的"></a>非阻塞应用存在的问题以及Netty是如何解决的</h3><h4 id="跨平台及兼容性问题"><a href="#跨平台及兼容性问题" class="headerlink" title="跨平台及兼容性问题"></a>跨平台及兼容性问题</h4><p>&emsp; &emsp; 非阻塞应用一般都会有跨平台问题，一个NIO应用在Linux上可以运行但在Window无法运行，同时还需要对低版本的兼容。NIO2.0只能在java7之后的版本运行，但它提供了一套统一的管理api，使其也能够在更低完本的jdk上运行，只不过有些功能受到了限制。</p>
<h4 id="修复e-poll-bug"><a href="#修复e-poll-bug" class="headerlink" title="修复e-poll bug"></a>修复e-poll bug</h4><p>&emsp; &emsp; 在Linux系统上，Java的NIO的Selector运用的是较为高效的e-poll机制，但是当连接较少时会存在一个很严重的bug导致cpu占用率很高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">          int selected = selector.select();                                #1</div><div class="line">          Set&lt;SelectedKeys&gt; readyKeys = selector.selectedKeys();</div><div class="line">          Iterator iterator = readyKeys.iterator();                        #2</div><div class="line">          while (iterator.hasNext()) &#123;                                     #3</div><div class="line">                 ... 													   #4</div><div class="line">			&#125; </div><div class="line">      &#125;</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>&emsp; &emsp; 在Linux系统中，#1处并没有阻塞，而是返回0，这样while循环会到时cpu上升到100%，即使到现在，这个问题仍然存在，不过幸运的是Netty避免了这个问题。</p>
]]></content>
      
        <categories>
            
            <category> 读书笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> netty </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈Java线程池]]></title>
      <url>/2017/08/15/%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>  Java中线程池是运用场景最多的并发框架，几乎所有的多任务或者异步并发任务都可以使用Java的线程池。在实际应用中，Java线程池的应用场景主要有以下几个：</p>
<ul>
<li>单任务执行时间短，并发量高</li>
<li>定时循环任务或者延迟任务</li>
<li>处理可以分解的大任务(ForkJoinPool)</li>
</ul>
<p>  在开发过程中合理地使用线程池可以带来的好处有以下几种:</p>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗</li>
<li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控</li>
</ul>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>  Executor 框架是从 Java 5 中引入的，其内部使用了线程池机制，它在 java.util.cocurrent 包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，在 Java 5之后，通过 Executor 来启动线程比使用 Thread 的 start 方法更好，更易管理，效率更高。Executor框架提供了Executors工厂方法，通过Executors可以创建我们需要的线程池。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image1.png" alt="Executor架构" title="Executor架构"></p>
<p>  Executor只提供了一个execute()方法提交任务，而其继承接口ExecutorService则丰富了其接口，不但提供了不同的任务提交方法，还提供了对线程池的管理的方法接口。AbstractExecutorService和ScheduledExecutorService是对ExecutorService更进一步的实现。而最终可以使用的实体类只有ThreadPoolExecutor和ScheduledThreadPoolExecutor。ThreadPoolExecutor会维护一个线程池，用户可以向线程池提交任务同时可以调用shunDown函数来关闭线程池，而ScheduledThreadPoolExecutor则专门用来执行定时或者循环任务，用户可以通过设置任务的执行时间来定时执行任务或者设置任务执行间隔时间来循环地执行任务。</p>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>  ThreadPoolExecutor通过execute来提交任务，通过corePoolSize和maximumPoolSize来控制线程池中线程的数量，通过设置keepAliveTime来控制线程空闲时长，通过BlockingQueue来存储用户提交的任务，通过RejectExecutionHandler来定义任务拒绝策略。</p>
<h4 id="ThreadPoolExecutor组成"><a href="#ThreadPoolExecutor组成" class="headerlink" title="ThreadPoolExecutor组成"></a>ThreadPoolExecutor组成</h4><p>  在详细介绍ThreadPoolExecutor之前，我们先了解下ThreadPoolExecutor的一些重要组成变量及内部类。</p>
<p>重要成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</div><div class="line"><span class="comment">//非核心线程空闲时长</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</div><div class="line"><span class="comment">//是否允许回收核心线程</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</div><div class="line"><span class="comment">//线程池核心线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</div><div class="line"><span class="comment">//线程池最大线程数</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</div></pre></td></tr></table></figure>
<ul>
<li><p>ctl是ThreadPoolExecutor类的核心，由两部分组成，高3位表示线程池的状态，低29位表示线程池中的线程数。如下图所示为ctl结构图</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image2.png" alt="ctl结构图" title="ctl结构图"></p>
</li>
<li><p>keepAliveTime：非核心线程空闲时长，如果非核心线程在keepAliveTime内没有获得可执行的任务，则会被回收</p>
</li>
<li>allowCoreThreadTimeOut：是否回收核心线程，如果为true表示可以回收核心线程，核心线程回收逻辑同非核心线程相同</li>
<li>corePoolSize：线程池允许的核心线程数</li>
<li>maximumPoolSize：线程池中允许的最大线程数量</li>
</ul>
<p>Worker线程内部类</p>
<p>  Worker实现了Runnable接口，是对线程池中线程的一个简单封装。当一个worker线程被创建并启用时，会调用ThreadPoolExecutor的runWorker方法来开始执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            runWorker(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor剖析"><a href="#ThreadPoolExecutor剖析" class="headerlink" title="ThreadPoolExecutor剖析"></a>ThreadPoolExecutor剖析</h4><p>  我们会从以下几个方面着手分析ThreadPoolExecutor</p>
<ul>
<li>线程池状态(线程池的生命周期)</li>
<li>execute任务提交过程(任务的流向)</li>
<li>Worker线程创建逻辑(线程的生命周期)</li>
<li>Worker线程销毁逻辑(线程的生命周期)</li>
</ul>
<h5 id="线程池状态-线程池的生命周期"><a href="#线程池状态-线程池的生命周期" class="headerlink" title="线程池状态(线程池的生命周期)"></a>线程池状态(线程池的生命周期)</h5><p>  ThreadPoolExecutor通过ctl的高三位存储线程池的状态，线程池共有五中状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;	<span class="comment">//29</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">//00011111111111111111111111111111 = 2^29 - 1</span></div><div class="line"><span class="comment">// runState is stored in the high-order bits</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;	<span class="comment">//11100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	<span class="comment">//00000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//00100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01100000000000000000000000000000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;	<span class="comment">//获取线程池状态</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;	<span class="comment">//获取线程池中线程的个数</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;		<span class="comment">//根据线程池状态和线程个数组合称ctrl</span></div></pre></td></tr></table></figure>
<ul>
<li>RUNNING：线程池正常运行，可接受新的任务或者消费队列中的任务</li>
<li>SHUTDOWN：线程池关闭(主线程调用shutdown方法)，不再接受新的任务，但会继续执行队列中的任务</li>
<li>STOP：线程池终止(主线程调用shudownNow方法)，既不接受新的任务也不再执行队列中的任务</li>
<li>TIDYING：所有的任务都被终止，线程数为0，所有线程都被终止。当线程池转换到TIDYING状态时会执行terminated(默认什么都不执行，由子类复写)方法</li>
<li>TERMINATED：TIDYING状态下执行完terminated方法，线程池转化为此状态</li>
</ul>
<p>线程池状态转换图:</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image3.png" alt="状态转换图" title="状态转换图"></p>
<h5 id="execute任务提交过程-任务的流向"><a href="#execute任务提交过程-任务的流向" class="headerlink" title="execute任务提交过程(任务的流向)"></a>execute任务提交过程(任务的流向)</h5><p>  execute方法用于用户提交任务，线程池对任务有三种处理方式:新建一个线程执行任务、放入queue队列或者拒绝任务执行。由于execute方法执行的时候并未加锁，因此会在多个地方进行double check线程池的状态。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image4.png" alt="任务提交流程图" title="任务提交流程图"></p>
<ol>
<li>工作线程数(workCount)小于核心线程数时新建一个核心线程执行提交的任务</li>
<li>工作线程数大于等于核心线程数并且任务队列(WorkQueue)未满时，将用户新提交的任务放入任务队列</li>
<li>任务队列满并且工作线程数小于最大线程数时，创建一个新的非核心线程执行提交的任务</li>
<li>工作线程数等于最大线程数且任务队列满时，则拒绝提交的任务</li>
</ol>
<p>BlockingQueue:任务存储队列，主要有以下几种队列</p>
<ul>
<li>LinkedBlockingQueue:无界的FIFO队列(maximumPoolSize失效)</li>
<li>ArrayBlockingQueue:有界FIFO队列</li>
<li>SynchronousQueue:不存储元素的阻塞队列，插入操作必须等待移除操作完成后才能执行，任务吞吐量比较高</li>
<li>ProorityBlockingQueue:具有优先级的无界阻塞队列</li>
</ul>
<p>RejectExecutionHandler:线程池不能接受新线程时拒绝策略,默认有以下几种策略</p>
<ul>
<li>AbortPolicy:直接抛异常（默认）</li>
<li>CallerRunsPolicy:由创建线程池的线程执行当前提交的任务</li>
<li>DiscardOldestPolicy:抛弃队列头的任务</li>
<li>DiscardPolicy:直接抛弃</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;    </div><div class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">// 线程池中线程数小于核心线程数(step1)</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();  <span class="comment">//如果增加线程失败，说明线程池状态发生变化，需要重新获取线程池状态</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程池正常，将任务放进队列中(step2)</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">//需要进行double check，防止在执行该方法时线程状态变化</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//如果线程处于非运行状态则需要移除该任务，并调用拒绝策略拒绝任务</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="comment">//线程池中线程数为0说明在执行该方法时主线程执行了shutdown操作，需要重新启动一个线程执行队列中的任务(由于workQueue.offer(command)执行成功，因此队列中至少有一个任务)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))	<span class="comment">//增加非核心线程(step3)</span></div><div class="line">        reject(command);    				<span class="comment">//拒绝任务(step4)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述为execute的源码，其中step1-step4对应上述的任务提交流程图的四个步骤</p>
<h5 id="Worker线程创建-线程生命周期"><a href="#Worker线程创建-线程生命周期" class="headerlink" title="Worker线程创建(线程生命周期)"></a>Worker线程创建(线程生命周期)</h5><p>  通过上边的execue的提交流程可知，ThreadPoolExecutor会在两种情况下新增一个Worker线程。</p>
<ul>
<li>线程池中线程数小于核心线程数</li>
<li>任务队列满并且线程池中线程数小于最大线程数</li>
</ul>
<p>  新增Worker主要有以下三个步骤:</p>
<ul>
<li>线程池状态检查：非RUNNING和SHUTDOWN状态下线程池拒绝创建新线程并拒绝提交任务，SHUTDOWN状态下不允许提交新任务，但是需要注意的是<strong>即使线程池处于SHUTDOWN状态，但如果任务队列中还有任务未执行完成，并且此时线程池中线程数量为0，线程池允许新建一个线程来消费任务队列中的任务</strong></li>
<li>线程池中线程数量检查：线程池线程数量 &gt;= CAPACITY || 核心线程数 &gt;= corePoolSize || 总线程数  &gt;= maximumPoolSize 不允许创建线程；</li>
<li>创建新线程并将其加到线程池中，同时调用start()启动线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">/*******************  1. 状态检查begin   *****************************/</span></div><div class="line"></div><div class="line">        <span class="comment">//等同于 rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></div><div class="line">        <span class="comment">//等同于 </span></div><div class="line">        <span class="comment">// 1. rs &gt; SHUTDOWN：不允许新增线程，不接受新任务</span></div><div class="line">        <span class="comment">// 2. rs = SHUTDOWN &amp;&amp; firstTask != null：不允许新增线程，并拒绝新任务</span></div><div class="line">        <span class="comment">// 3. rs = SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty(): 线程池关闭，任务队列中的任务为空，不再允许提交新的任务</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        </div><div class="line">        <span class="comment">/*******************  2. 线程池数量检查begin     *****************************/</span></div><div class="line">      	<span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">//1. 线程数 &gt;= CAPACITY</span></div><div class="line">          	<span class="comment">//2. 线程数 &gt;= corePoolSize时不允许创建核心线程</span></div><div class="line">          	<span class="comment">//3. 线程数  &gt;= maximumPoolSize 不允许创建非核心线程</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//增加线程数成功，跳出retry循环</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">//re-check线程池状态，不一致说明触发了线程池状态变更，需要重新验证是否需要创建新的线程</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  	<span class="comment">/*******************  3.创建并运行线程begin     *****************************/</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// 1. 线程池处于正常运行时，新增线程ok</span></div><div class="line">                <span class="comment">// 2. rs = SHUTDOWN状态下，只有firstTask为null时才允许新增线程,见execute(),线程池关闭并且线程数为0</span></div><div class="line">                <span class="comment">//但任务队列中还有未完成的任务.</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                t.start();  <span class="comment">//启动线程</span></div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="Worker线程销毁逻辑-线程生命周期"><a href="#Worker线程销毁逻辑-线程生命周期" class="headerlink" title="Worker线程销毁逻辑(线程生命周期)"></a>Worker线程销毁逻辑(线程生命周期)</h5><p>  ThreadPoolExecutor通过addWorker函数新增并启动一个工作线程，通过上边的Worker源码可知，Worker线程执行的是ThreadPoolExecutor.runWorker(Worker)里面的逻辑。runWorker主要做了以下几个工作:</p>
<ul>
<li>获取需要执行的任务，初始化任务或者从任务队列中获取的任务</li>
<li>检查线程池状态，保证线程池能够及时中断</li>
<li>beforeExecute—&gt;task.run()—&gt;afterExecute</li>
<li>退出while循环后，执行processWorkerExit方法，中断一个空闲线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">   	Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;    <span class="comment">//先执行初始化时的任务</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">//主要用来判断线程是正常结束还是异常结束，true为异常结束，在processWorkerExit中用来标志是否将线程池中的线程数减一</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">// task是控制线程周期的重要因素</span></div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">          	<span class="comment">//判断线程池状态，中断线程</span></div><div class="line">          	<span class="comment">// 线程池状态&gt;=STOP并且线程未被中断，需要中断线程</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//执行自定义的任务执行前操作，默认什么也不执行</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//执行任务</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                  	<span class="comment">//任务执行后执行的操作，默认什么也不执行</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      	<span class="comment">//线程退出后执行清理工作</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  由上述源码可知线程池中的线程通过while循环来保证线程正常进行，任务来源是初始化任务firstTask或者通过getTask(从任务队列中获取任务)，当线程获取到的任务为空时则退出while循环，结束线程生命周期。所以task是否为空控制着线程的生命周期，而task的来源是getTask函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回null则退出线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">      	<span class="comment">// 1. rs &gt; SHUTDOWN：线程池关闭，回收该线程</span></div><div class="line">      	<span class="comment">// 2. rs = SHUTDOWN &amp;&amp; workQueue.isEmpty():任务队列中任务执行完毕，回收该线程</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// timed表示是否需要回收该线程，如果allowCoreThreadTimeOut设置为true则无论当前线程数</span></div><div class="line">        <span class="comment">// 设置多少都需要回收，否则只有当线程池中线程数大于corePoolSize时才需要回收</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        <span class="comment">//需要回收线程时，则将线程数减一，并返回null，在runWorker中回收线程</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//1：如果timed为true，该线程需要回收，通过将workQueue.poll的超时时间设置为</span></div><div class="line">            <span class="comment">// keepAliveTime来保证返回的task是否为空，从而来判断该线程是否需要回收</span></div><div class="line">            <span class="comment">// 2：timed为false，则阻塞获取workQueue，直到线程中断或者获取到任务</span></div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  由上述源码可知getTask是通过workQueue的poll来hold当前工作线程keepAlive时长，从而实现工作线程空闲keepAliveTime能够及时回收。</p>
<p>​                    <img src="/2017/08/15/浅谈Java线程池/image5.png" alt="getTask" title="getTask"></p>
<h3 id="ScheduleThreadPoolExecutor"><a href="#ScheduleThreadPoolExecutor" class="headerlink" title="ScheduleThreadPoolExecutor"></a>ScheduleThreadPoolExecutor</h3><p>  ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，所以其新增和回收线程逻辑，执行任务方式都沿用了ThreadPoolExecutor的逻辑。ScheduledThreadPoolExecutor之所以能够执行定时任务和延迟任务，主要是其自定义实现了一个DelayQueue并封装了一个ScheduledFutureTask(extend FutureTask)，其中DelayWorkQueue维护着一个最小堆，最先需要执行的任务在堆顶。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>  ScheduledThreadPoolExecutor本质是一个ThreadPoolExecutor，其构造函数直接t通过super来完成对象的初始化。默认ScheduledThreadPoolExecutor的maximumPoolSize为Integer.MAX_VALUE，keepAliveTime=0，任务队列为DelayedWorkQueue。但是由于DelayedWorkQueue无限增长(最大值Integer.MAX_VALUE),其相当于一个无界队列，所以设置maximumPoolSize基本上是无效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><p>  ScheduledFutureTask是ScheduledThreadPoolExecutor对任务的封装，其中包含了该任务的类型(period)、下次需要执行的时间(time)以及在任务队列中的位置(heapInex)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">  	<span class="comment">//入队列的序号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line">  	<span class="comment">//任务执行的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</div><div class="line"></div><div class="line">  	<span class="comment">//任务类型</span></div><div class="line">  	<span class="comment">//正数:按固定频率执行</span></div><div class="line">  	<span class="comment">//0：非重复执行的任务</span></div><div class="line">  	<span class="comment">// 负数：按固定延迟执行</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</div><div class="line"></div><div class="line">    <span class="comment">/** The actual task to be re-enqueued by reExecutePeriodic */</span></div><div class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">  	<span class="comment">// 在任务队列数组中的索引</span></div><div class="line">    <span class="keyword">int</span> heapIndex;</div></pre></td></tr></table></figure>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p>  DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p>
<h5 id="排序规则："><a href="#排序规则：" class="headerlink" title="排序规则："></a>排序规则：</h5><ul>
<li>执行时间距离当前时间越近，越靠前</li>
<li>如果执行时间相同，则先执行插入时间靠前的任务。</li>
</ul>
<h4 id="获取任务-take"><a href="#获取任务-take" class="headerlink" title="获取任务(take)"></a>获取任务(take)</h4><p>  take函数主要是获取任务队列最小堆中的第一个任务，其使用了leader-follower模式，关于leader-follower模式可以参考这篇<a href="http://blog.csdn.net/goldlevi/article/details/7705180" target="_blank" rel="external">博客</a>。</p>
<blockquote>
<p>leader-follower模式中，所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<ul>
<li>获取任务队列堆顶元素，如果为null则进入wail状态，等待offer的signal唤醒</li>
<li>如果堆顶任务执行时间小于当前时间，则返回堆顶任务</li>
<li>如果leader为空，则将当前线程设置为leader，并等待至堆顶任务执行时间</li>
<li>如果leader已存在，则进入wait状态，等待被唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)	<span class="comment">//队列中没有任务，需要等待offer函数唤醒</span></div><div class="line">                available.await();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)	<span class="comment">//到任务的执行时间，执行该任务</span></div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)	<span class="comment">//当leader线程不为null时说明有leader线程在等待第一个任务，其他线程进入wait状态</span></div><div class="line">                    available.await();</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;	<span class="comment">//设置为leader线程</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      <span class="comment">//等待delay时间，</span></div><div class="line">                        available.awaitNanos(delay);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;	<span class="comment">//将leader设置为null并在下一个循环中获取任务</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();	<span class="comment">//唤醒其他线程</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="新增任务"><a href="#新增任务" class="headerlink" title="新增任务"></a>新增任务</h4><p>  ScheduledThreadPoolExecutor支持三种新增任务的方式，新增普通延迟任务，新增固定频率执行任务，新增固定频率执行的延迟任务。</p>
<ol>
<li>通过schedule函数直接新增一条延迟执行的任务(ScheduleThreadPoolExecutor.schedule)</li>
<li>通过scheduleAtFixedRate新增一条按固定频率执行的任务(ScheduleThreadPoolExecutor.scheduleAtFixedRate)</li>
<li>通过scheduleWithFixedDelay新增一条固定频率执行的延迟任务(ScheduleThreadPoolExecutor.scheduleWithFixedDelay)</li>
</ol>
<p>  ScheduledThreadPoolExecutor是如何实现定时任务和延迟任务的呢？由上面可知ScheduledThreadPoolExecutor重新封装了task也就是ScheduledFutureTask，而定时和延迟任务的执行就在ScheduledFutureTask的run中完成的。任务下次执行时间:</p>
<ul>
<li><p>非周期循环任务，无下次执行时间</p>
</li>
<li><p>定时周期任务：上次执行时间+延迟时间</p>
</li>
<li><p>延迟周期任务：当前时间+延迟时间</p>
<p>​    <img src="/2017/08/15/浅谈Java线程池/image6.png" alt="周期任务执行时间序列图" title="周期任务执行时间序列图"></p>
</li>
</ul>
<img src="/2017/08/15/浅谈Java线程池/image7.png" alt="任务执行步骤" title="任务执行步骤">
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">//判断是否是定时任务</span></div><div class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</div><div class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</div><div class="line">        cancel(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</div><div class="line">      	<span class="comment">//非循环任务，直接执行</span></div><div class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</div><div class="line">      	<span class="comment">//循环任务任务，执行完后设置下次执行的时间</span></div><div class="line">        setNextRunTime();</div><div class="line">        reExecutePeriodic(outerTask);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">long</span> p = period;</div><div class="line">  			<span class="comment">//循环任务直接在本次执行时间上加上时间间隔</span></div><div class="line">            <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</div><div class="line">                time += p;</div><div class="line">            <span class="keyword">else</span></div><div class="line">              <span class="comment">//延迟定时任务则将当前时间+延迟时间作为下次执行的时间</span></div><div class="line">                time = triggerTime(-p);</div><div class="line">        &#125;</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> now() +</div><div class="line">            ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="Executors工厂类"><a href="#Executors工厂类" class="headerlink" title="Executors工厂类"></a>Executors工厂类</h3><p>  Executors是一个线程池的工厂类，用户可以通过调用其静态函数来创建不同的线程池，常用的线程池有以下几个:</p>
<ol>
<li><p>newFixedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newFixedThreadPool返回特定线程数的线程池，但需要注意的是<strong>newFixedThreadPool的任务队列是LinkedBlockingQueue无界队列，如果生产者速度大于消费者会造成jvm频繁full gc</strong></p>
</li>
<li><p>newSingleThreadExecutor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newSingleThreadExecutor返回只有一个线程的线程池，其并没有返回ThreadPoolExecutor对象，而是返回FinalizableDelegatedExecutorService的一个代理类，主要是为了屏蔽一些不必要的操作，例如allowCoreThreadTimeOut()。通newFixedThreadPool一样，newSingleThreadExecutor也是使用LinkedBlockingQueue无界队列来存储任务的。</p>
</li>
<li><p>newCachedThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newCachedThreadPool利用SynchronousQueue作为任务队列，核心线程数设置为0，线程最大空闲时间为60s。newCachedThreadPool实现了一个线程缓存池，当提交任务比较频繁时可以快速创建新的线程处理任务，任务提交不频繁时又可以优雅地回收线程。其适用于处理吞吐量比较高的场景。</p>
</li>
<li><p>newScheduledThreadPool</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>newScheduledThreadPool返回一个定时执行任务的线程池，类似于Timer。</p>
</li>
</ol>
<h2 id="线程池分配"><a href="#线程池分配" class="headerlink" title="线程池分配"></a>线程池分配</h2><p>  合理地配置线程池，需要对任务的特性进行分析，可以从以下几个角度进行分析</p>
<ol>
<li><p>任务的性质：CPU密集型、IO密集型还是混合密集型。一般来说CPU密集型可以将线程池数设置为CPU+1，IO密集型可以将线程数设置为2*CPU，混合型的最好能够拆分成CPU密集型和IO密集型两个线程池，这种计算方式适用于一台机器上只跑一个服务的情况。</p>
</li>
<li><p>多应用，多任务线程计算公式：最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目或者进一步转化后:最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</p>
</li>
<li><p>任务优先级：高、中、低任务优先级，可以使用PriorityBlockQueue来存储任务</p>
</li>
<li><p>任务执行的时长：长、中、短等，不同时长的任务可以分发给不同的线程池来执行，或者使用PriorityBlockQueue来保证执行时间短的任务先执行。</p>
</li>
<li><p>任务的依赖：是否依赖其他资源，可以根据所依赖的资源的类型来判断执行任务的类型。</p>
<p>​</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[ScheduledThreadPoolExecutor源码分析]]></title>
      <url>/2017/08/11/ScheduledThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  对于一般的多任务执行，ThreadPoolExecutor可以满足大部分需求。但是有时候我们需要定时或者延迟地去执行一个任务，这个时候ThreadPoolExecutor已经不能满足我们的需求了，所以Java提供了ScheduledThreadPoolExecutor来执行定时或延迟任务。</p>
<h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p>​    ScheduledThreadPoolExecutor继承了<a href="/2017/08/08/ThreadPoolExecutor源码分析/">ThreadPoolExecutor</a>，所以其新增和回收线程逻辑，执行任务方式都沿用了ThreadPoolExecutor的逻辑。ScheduledThreadPoolExecutor之所以能够执行定时任务和延迟任务，主要是其自定义实现了一个DelayQueue并封装了一个ScheduledFutureTask(extend FutureTask)。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>  ScheduledThreadPoolExecutor本质是一个ThreadPoolExecutor，其构造函数直接t通过super来完成对象的初始化。默认ScheduledThreadPoolExecutor的maximumPoolSize为Integer.MAX_VALUE，keepAliveTime=0，任务队列为DelayedWorkQueue。但是由于DelayedWorkQueue是无界队列，所以设置maximumPoolSize是无效的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><p>  ScheduledFutureTask是ScheduledThreadPoolExecutor对任务的封装，其中包含了该任务的类型(period)、下次需要执行的时间(time)以及在任务队列中的位置(heapInex)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledFutureTask</span>&lt;<span class="title">V</span>&gt;</span></div><div class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableScheduledFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/** Sequence number to break ties FIFO */</span></div><div class="line">  	<span class="comment">//入队列的序号</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</div><div class="line"></div><div class="line">    <span class="comment">/** The time the task is enabled to execute in nanoTime units */</span></div><div class="line">  	<span class="comment">//任务执行的时间</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Period in nanoseconds for repeating tasks.  A positive</span></div><div class="line"><span class="comment">     * value indicates fixed-rate execution.  A negative value</span></div><div class="line"><span class="comment">     * indicates fixed-delay execution.  A value of 0 indicates a</span></div><div class="line"><span class="comment">     * non-repeating task.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  	<span class="comment">//任务类型</span></div><div class="line">  	<span class="comment">//正数:按固定频率执行</span></div><div class="line">  	<span class="comment">//0：非重复执行的任务</span></div><div class="line">  	<span class="comment">// 负数：按固定延迟执行</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</div><div class="line"></div><div class="line">    <span class="comment">/** The actual task to be re-enqueued by reExecutePeriodic */</span></div><div class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="keyword">this</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * Index into delay queue, to support faster cancellation.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">  	<span class="comment">// 在任务队列数组中的索引</span></div><div class="line">    <span class="keyword">int</span> heapIndex;</div></pre></td></tr></table></figure>
<h4 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h4><p>  DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p>
<h5 id="排序规则："><a href="#排序规则：" class="headerlink" title="排序规则："></a>排序规则：</h5><ul>
<li>执行时间距离当前时间越近，越靠前</li>
<li>如果执行时间相同，则先执行插入时间靠前的任务。</li>
</ul>
<h5 id="新增-获取任务"><a href="#新增-获取任务" class="headerlink" title="新增/获取任务"></a>新增/获取任务</h5><p>  DelayedWorkQueue通过put或者add来新增一条任务，但其底层都是调用offer来新增任务的。对于获取任务，我们知道在ThreadPoolExecutor中线程根据getTask来获取任务队列中的任务，而在getTask中任务队列通过poll或者take函数来获取任务队列中的任务，由于ScheduleThreadPoolExecutor继承自ThreadPoolExecutor，因此其底层获取任务方式相同，只需要DelayedWorkQueue提供take及pool方法即可。</p>
<p>  在分析offer、take及poll之前，我们先看下siftUp及siftDown函数。</p>
<p>  DelayWorkQueue底层是用最小堆数据结构实现的，需要最先执行的任务在堆的顶部，因此在每次插入或者删除任务时需要调整二叉树节点的顺序，但不同于最小堆的地方在于DelayWorkQueue不关心兄弟节点之间的顺序，只要父节点的任务先于子节点执行即可。</p>
<p>  在一个最小堆的队列中，假如索引从0开始，子节点索引值为k，父节点索引值为p，则存在如下规律：</p>
<ol>
<li>一个节点的左子节点的索引为：k = p * 2 + 1；</li>
<li>一个节点的右子节点的索引为：k = (p + 1) * 2；</li>
<li>一个节点的父节点的索引为：p = (k - 1) / 2。</li>
</ol>
<p>  siftUp函数在新增一个任务时调用，通过循环对比父子节点任务执行的先后顺序来调整新任务在堆中的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sifts element added at bottom up to its heap-ordered spot.</span></div><div class="line"><span class="comment"> * Call only when holding lock.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;	<span class="comment">//查找到父节点</span></div><div class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent];	<span class="comment">//获取父节点任务</span></div><div class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>)	<span class="comment">//如果父节点先于该任务执行，则跳出循环</span></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = e;	<span class="comment">//与父节点交换位置</span></div><div class="line">        setIndex(e, k);</div><div class="line">        k = parent;	<span class="comment">//重新向上追溯父节点</span></div><div class="line">    &#125;</div><div class="line">    queue[k] = key;	</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  siftDown函数是将一个任务从k节点一层一层地最小堆的底层沉淀，能够保证执行完后最小堆中的父节点任务先于子节点执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sifts element added at top down to its heap-ordered spot.</span></div><div class="line"><span class="comment"> * Call only when holding lock.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</div><div class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</div><div class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</div><div class="line">            c = queue[child = right];</div><div class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        queue[k] = c;</div><div class="line">        setIndex(c, k);</div><div class="line">        k = child;</div><div class="line">    &#125;</div><div class="line">    queue[k] = key;</div><div class="line">    setIndex(key, k);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="take"><a href="#take" class="headerlink" title="take"></a>take</h4><p>  take函数主要是获取任务队列最小堆中的第一个任务，其使用了leader-follower模式，关于leader-follower模式可以参考这篇<a href="http://blog.csdn.net/goldlevi/article/details/7705180" target="_blank" rel="external">博客</a>。</p>
<blockquote>
<p>leader-follower模式中，所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<ul>
<li>获取任务队列堆顶元素，如果为null则进入wail状态，等待offer的signal唤醒</li>
<li>如果堆顶任务执行时间小于当前时间，则返回堆顶任务</li>
<li>如果leader为空，则将当前线程设置为leader，并等待至堆顶任务执行时间</li>
<li>如果leader已存在，则进入wait状态，等待被唤醒。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)	<span class="comment">//队列中没有任务，需要等待offer函数唤醒</span></div><div class="line">                available.await();</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)	<span class="comment">//到任务的执行时间，执行该任务</span></div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)	<span class="comment">//当leader线程不为null时说明有leader线程在等待第一个任务，其他线程进入wait状态</span></div><div class="line">                    available.await();</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;	<span class="comment">//设置为leader线程</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      <span class="comment">//等待delay时间，</span></div><div class="line">                        available.awaitNanos(delay);</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;	<span class="comment">//将leader设置为null并在下一个循环中获取任务</span></div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();	<span class="comment">//唤醒其他线程</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>  poll的功能和take相似，入参多了一个timeout，如果在timeout时间内获取不到任务则直接返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</div><div class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">else</span></div><div class="line">                  	<span class="comment">//等待timeout</span></div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</div><div class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> finishPoll(first);</div><div class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;	<span class="comment">//未获得任务，则返回空</span></div><div class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></div><div class="line">              	<span class="comment">//超时时间&lt;延迟时间或者其他线程正在执行任务，则进入等待状态</span></div><div class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</div><div class="line">                    nanos = available.awaitNanos(nanos);</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    Thread thisThread = Thread.currentThread();</div><div class="line">                    leader = thisThread;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                      	<span class="comment">//timeLeft = delay-实际等待时间</span></div><div class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</div><div class="line">                      <span class="comment">//计算剩余超时时长</span></div><div class="line">                        nanos -= delay - timeLeft;</div><div class="line">                    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                        <span class="keyword">if</span> (leader == thisThread)</div><div class="line">                            leader = <span class="keyword">null</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</div><div class="line">            available.signal();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="offer"><a href="#offer" class="headerlink" title="offer"></a>offer</h4><p>  offer是DelayQueue底层往任务列表中新增一个任务的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">int</span> i = size;</div><div class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</div><div class="line">            grow();	<span class="comment">//按1.5倍增长</span></div><div class="line">        size = i + <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</div><div class="line">            queue[<span class="number">0</span>] = e;</div><div class="line">            setIndex(e, <span class="number">0</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            siftUp(i, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</div><div class="line">            leader = <span class="keyword">null</span>;</div><div class="line">            available.signal();	<span class="comment">//唤醒take或者poll中阻塞的一个线程</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="新增任务"><a href="#新增任务" class="headerlink" title="新增任务"></a>新增任务</h3><p>  ScheduledThreadPoolExecutor支持三种新增任务的方式，新增普通延迟任务，新增固定频率执行任务，新增固定频率执行的延迟任务。</p>
<ol>
<li>通过schedule函数直接新增一条延迟任务</li>
<li>通过scheduleAtFixedRate新增一条按固定频率执行的任务</li>
<li>通过scheduleWithFixedDelay新增一条固定频率执行的延迟任务</li>
</ol>
<p>ScheduledThreadPoolExecutor是如何实现定时任务和延迟任务的呢？由上面可知ScheduledThreadPoolExecutor重新封装了task也就是ScheduledFutureTask，而定时和延迟任务的执行就在ScheduledFutureTask的run中完成的。任务下次执行时间:</p>
<ul>
<li><p>非周期循环任务，无下次执行时间</p>
</li>
<li><p>定时周期任务：上次执行时间+延迟时间</p>
</li>
<li><p>延迟周期任务：当前时间+延迟时间</p>
<p>​    </p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  	<span class="comment">//判断是否是定时任务</span></div><div class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</div><div class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</div><div class="line">        cancel(<span class="keyword">false</span>);</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</div><div class="line">      	<span class="comment">//正常任务，直接执行</span></div><div class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</div><div class="line">      	<span class="comment">//非定时任务，执行完后设置下次执行的时间</span></div><div class="line">        setNextRunTime();</div><div class="line">        reExecutePeriodic(outerTask);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">long</span> p = period;</div><div class="line">  			<span class="comment">//循环任务直接在本次执行时间上加上时间间隔</span></div><div class="line">            <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</div><div class="line">                time += p;</div><div class="line">            <span class="keyword">else</span></div><div class="line">              <span class="comment">//延迟定时任务则将当前时间+延迟时间作为下次执行的时间</span></div><div class="line">                time = triggerTime(-p);</div><div class="line">        &#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">triggerTime</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> now() +</div><div class="line">            ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</div><div class="line">    &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ThreadPoolExecutor源码分析]]></title>
      <url>/2017/08/08/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>  线程是程序执行的最小单元，合理的使用线程可以充分利用系统资源、提高吞吐率以及加快响应时间。然而在实际应用中，很多线程都是朝生夕死的。而创建和销毁线程又极大的耗费系统资源，因此从jdk1.5开始引入了线程池的概念，用户可以使用Executors静态工厂类来创建各种各样的满足自己的需求的线程池。一般来说最常用的线程池主要有以下三种:</p>
<ul>
<li>ThreadPoolExecutor：基础多任务线程池框架。</li>
<li>ScheduledThreadPoolExecutor：继承自ThreadPoolExecutor，通过实现延时队列实现定时任务</li>
<li>ForkJoinPool(&gt;=jdk1.7)：并行任务框架，利用多核处理器并行执行任务</li>
</ul>
<h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p>  ThreadPoolExecutor在初始化之前可以根据用户的配置来维护一个线程池来执行用户提交的任务。其核心方法是execute()，用来提交并执行任务(实现了Runnable接口)，同时通过shutDown和shutDownNow来实现对线程池的生命周期的管理。在介绍核心方法之前，我们先介绍一些ThreadPoolExecutor的重要组成变量或类</p>
<h4 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</div></pre></td></tr></table></figure>
<p>  ctl是ThreadPoolExecutor类的核心，其包含了线程池运行状态以及线程池中的线程数，利用AtomicInteger来保证对这个变量的修改是原子性的。如下图所示为ctl结构图</p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor1.png" alt="ctl结构图" title="ctl结构图"></p>
<p>ctl的低29位用来表示线程池中线程的数量，高3位用来表示线程池的运行状态。</p>
<p>线程池的运行状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;	<span class="comment">//29</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;	<span class="comment">//00011111111111111111111111111111 = 2^29 - 1</span></div><div class="line"><span class="comment">// runState is stored in the high-order bits</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;	<span class="comment">//11100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;	<span class="comment">//00000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">//00100000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01000000000000000000000000000000</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;	<span class="comment">//01100000000000000000000000000000</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;	<span class="comment">//获取线程池状态</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;	<span class="comment">//获取线程池中线程的个数</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;		<span class="comment">//根据线程池状态和线程个数组合称ctrl</span></div></pre></td></tr></table></figure>
<ul>
<li>RUNNING：线程池正常运行，可接受新的任务或者消费队列中的任务</li>
<li>SHUTDOWN：线程池关闭(主线程调用shutdown方法)，不再接受新的任务，但会继续执行队列中的任务</li>
<li>STOP：线程池终止(主线程调用shudownNow方法)，既不接受新的任务也不再执行队列中的任务</li>
<li>TIDYING：所有的任务都被终止，线程数为0，所有线程都被终止。当线程池转换到TIDYING状态时会执行terminated(默认什么都不执行，由子类复写)方法</li>
<li>TERMINATED：TIDYING状态下执行完terminated方法，线程池转化为此状态</li>
</ul>
<p>线程池状态转换图:</p>
<p>​                    <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor2.png" alt="状态转换图" title="状态转换图"></p>
<p>后两种状态相对来说比较复杂，我们这里着重关注前三种状态即可。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></div><div class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  先来看一下构造函数的入参:</p>
<ol>
<li>corePoolSize:线程池核心线程数</li>
<li>maximumPoolSize:线程池最大线程数</li>
<li>keepAliveTime:线程空闲时存活时长，当allowCoreThreadTimeOut=true时，核心线程也会被回收</li>
<li>unit:keepAliveTime的单位</li>
<li>workQueue:任务存储队列，主要有以下几种队列<ul>
<li>LinkedBlockingQueue:无界的FIFO队列(maximumPoolSize失效)</li>
<li>ArrayBlockingQueue:有界FIFO队列</li>
<li>SynchronousQueue:不存储元素的阻塞队列，插入操作必须等待移除操作完成后才能执行</li>
<li>ProorityBlockingQueue:具有优先级的无界阻塞队列</li>
</ul>
</li>
<li>threadFactory:创建线程的工厂类(默认为DefaultThreadFactory)</li>
<li>handler:线程池不能接受新线程时拒绝策略,默认有以下几种策略<ul>
<li>AbortPolicy:直接抛异常（默认）</li>
<li>CallerRunsPolicy:由创建线程池的线程执行当前提交的任务</li>
<li>DiscardOldestPolicy:抛弃队列头的任务</li>
<li>DiscardPolicy:直接抛弃</li>
</ul>
</li>
</ol>
<p>线程池的上面的几个参数决定了线程创建策略以及任务执行过程，如下图所示为一个任务提交执行的流程:</p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor3.png" alt="任务提交流程图" title="任务提交流程图"></p>
<p>​                        <img src="/2017/08/08/ThreadPoolExecutor源码分析/ThreadPoolExecutor4.png" alt="任务提交流程图" title="任务提交流程图"></p>
<h4 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h4><p>  Worker是线程池中线程的基本单位，其对线程进行了一个简单的包装，本身实现了Runnable接口。同时Worker继承自AbstractQueuedSynchronizer(<a href="http://ifeve.com/java-special-troops-aqs/" target="_blank" rel="external">AQS</a>)，实现了一份简单的非重入互斥锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></div><div class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></div><div class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">      <span class="comment">/** worker运行的线程 */</span></div><div class="line">        <span class="keyword">final</span> Thread thread;</div><div class="line">        <span class="comment">/** 初始化时提交的任务，可能为null*/</span></div><div class="line">        Runnable firstTask;</div><div class="line">        <span class="comment">/** workder完成的任务数*/</span></div><div class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</div><div class="line">  		...</div><div class="line">        </div><div class="line">        <span class="comment">//加锁</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">                setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//释放锁</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</div><div class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">            setState(<span class="number">0</span>);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="ThreadPoolExecutor重要方法"><a href="#ThreadPoolExecutor重要方法" class="headerlink" title="ThreadPoolExecutor重要方法"></a>ThreadPoolExecutor重要方法</h3><h4 id="execute-Runnable-command-提交任务"><a href="#execute-Runnable-command-提交任务" class="headerlink" title="execute(Runnable command)提交任务"></a>execute(Runnable command)提交任务</h4><p>  execute方法用于用户提交任务，线程池对任务有三种处理方式:新建一个线程执行任务、放入queue队列或者拒绝任务执行。由于execute方法执行的时候并未加锁，因此会在多个地方进行double check线程池的状态。</p>
<ul>
<li>尝试增加核心线程(step1)</li>
<li>尝试将任务放入任务队列(step2)</li>
<li>尝试增加非核心线程(step3)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;    </div><div class="line">	<span class="keyword">if</span> (command == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Proceed in 3 steps:</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 1. If fewer than corePoolSize threads are running, try to</span></div><div class="line"><span class="comment">     * start a new thread with the given command as its first</span></div><div class="line"><span class="comment">     * task.  The call to addWorker atomically checks runState and</span></div><div class="line"><span class="comment">     * workerCount, and so prevents false alarms that would add</span></div><div class="line"><span class="comment">     * threads when it shouldn't, by returning false.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 2. If a task can be successfully queued, then we still need</span></div><div class="line"><span class="comment">     * to double-check whether we should have added a thread</span></div><div class="line"><span class="comment">     * (because existing ones died since last checking) or that</span></div><div class="line"><span class="comment">     * the pool shut down since entry into this method. So we</span></div><div class="line"><span class="comment">     * recheck state and if necessary roll back the enqueuing if</span></div><div class="line"><span class="comment">     * stopped, or start a new thread if there are none.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 3. If we cannot queue task, then we try to add a new</span></div><div class="line"><span class="comment">     * thread.  If it fails, we know we are shut down or saturated</span></div><div class="line"><span class="comment">     * and so reject the task.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line">    <span class="comment">// 线程池中线程数小于核心线程数(step1)</span></div><div class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</div><div class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        c = ctl.get();  <span class="comment">//如果增加线程失败，说明线程池状态发生变化，需要重新获取线程池状态</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//线程池正常，将任务放进队列中(step2)</span></div><div class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</div><div class="line">        <span class="comment">//需要进行double check，防止在执行该方法时线程状态变化</span></div><div class="line">        <span class="keyword">int</span> recheck = ctl.get();</div><div class="line">        <span class="comment">//如果线程处于非运行状态则需要移除该任务，并调用拒绝策略拒绝任务</span></div><div class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</div><div class="line">            reject(command);</div><div class="line">        <span class="comment">//线程池中线程数为0说明在执行该方法时主线程执行了shutdown操作，需要重新启动一个线程执行队列中的任务(由于workQueue.offer(command)执行成功，因此队列中至少有一个任务)</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</div><div class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))	<span class="comment">//增加非核心线程(step3)</span></div><div class="line">        reject(command);    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="addWorker-Runnable-firstTask-boolean-core-新增线程，并处理当前任务"><a href="#addWorker-Runnable-firstTask-boolean-core-新增线程，并处理当前任务" class="headerlink" title="addWorker(Runnable firstTask, boolean core) 新增线程，并处理当前任务"></a>addWorker(Runnable firstTask, boolean core) 新增线程，并处理当前任务</h4><ul>
<li>firstTask:创建线程时当前需要执行的任务</li>
<li>core:创建的线程是否是核心线程(true:核心线程,false:非核心线程)</li>
</ul>
<p>新增Worker主要有以下三个步骤:</p>
<ul>
<li>线程池状态检查：非RUNNING和SHUTDOWN状态下线程池拒绝创建新线程并拒绝提交任务，SHUTDOWN状态下不允许提交新任务，但在线程池中线程数为0并且任务队列不为空时才允许创建一个线程来执行任务队列中剩余的任务。</li>
<li>线程池中线程数量检查：线程池线程数量 &gt;= CAPACITY || 核心线程数 &gt;= corePoolSize || 总线程数  &gt;= maximumPoolSize 不允许创建线程；</li>
<li>创建新线程并将其加到线程池中，同时调用start()启动线程。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</div><div class="line">    retry:</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">/*******************  1. 状态检查begin   *****************************/</span></div><div class="line"></div><div class="line">        <span class="comment">//等同于 rs &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())</span></div><div class="line">        <span class="comment">//等同于 </span></div><div class="line">        <span class="comment">// 1. rs &gt; SHUTDOWN：不允许新增线程，不接受新任务</span></div><div class="line">        <span class="comment">// 2. rs = SHUTDOWN &amp;&amp; firstTask != null：不允许新增线程，并拒绝新任务</span></div><div class="line">        <span class="comment">// 3. rs = SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue.isEmpty(): 线程池关闭，任务队列中的任务为空，不再允许提交新的任务</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</div><div class="line">            ! (rs == SHUTDOWN &amp;&amp;</div><div class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</div><div class="line">               ! workQueue.isEmpty()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">        <span class="comment">/*******************  状态检查end     *****************************/</span></div><div class="line">        </div><div class="line">        <span class="comment">/*******************  2. 线程池数量检查begin     *****************************/</span></div><div class="line">      	<span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line">            <span class="comment">//1. 线程数 &gt;= CAPACITY</span></div><div class="line">          	<span class="comment">//2. 线程数 &gt;= corePoolSize时不允许创建核心线程</span></div><div class="line">          	<span class="comment">//3. 线程数  &gt;= maximumPoolSize 不允许创建非核心线程</span></div><div class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</div><div class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            <span class="comment">//增加线程数成功，跳出retry循环</span></div><div class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</div><div class="line">                <span class="keyword">break</span> retry;</div><div class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></div><div class="line">            <span class="comment">//re-check线程池状态，不一致说明触发了线程池状态变更，需要重新验证是否需要创建新的线程</span></div><div class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</div><div class="line">                <span class="keyword">continue</span> retry;</div><div class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">     <span class="comment">/*******************  线程池数量检查end     *****************************/</span></div><div class="line"></div><div class="line">  	<span class="comment">/*******************  3.创建并运行线程begin     *****************************/</span></div><div class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</div><div class="line">    Worker w = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        w = <span class="keyword">new</span> Worker(firstTask);</div><div class="line">        <span class="keyword">final</span> Thread t = w.thread;</div><div class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">            mainLock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// Recheck while holding lock.</span></div><div class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></div><div class="line">                <span class="comment">// shut down before lock acquired.</span></div><div class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</div><div class="line">                <span class="comment">// 1. 线程池处于正常运行时，新增线程ok</span></div><div class="line">                <span class="comment">// 2. rs = SHUTDOWN状态下，只有firstTask为null时才允许新增线程,见execute(),线程池关闭并且线程数为0</span></div><div class="line">                <span class="comment">//但任务队列中还有未完成的任务.</span></div><div class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</div><div class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</div><div class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</div><div class="line">                    workers.add(w);</div><div class="line">                    <span class="keyword">int</span> s = workers.size();</div><div class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</div><div class="line">                        largestPoolSize = s;</div><div class="line">                    workerAdded = <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                mainLock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (workerAdded) &#123;</div><div class="line">                t.start();  <span class="comment">//启动线程</span></div><div class="line">                workerStarted = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (! workerStarted)</div><div class="line">            addWorkerFailed(w);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> workerStarted;</div><div class="line">    <span class="comment">/*******************  3.创建并运行线程end     *****************************/</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Worker-run"><a href="#Worker-run" class="headerlink" title="Worker.run()"></a>Worker.run()</h4><p>  由于Worker本身实现了Runable接口，因此主线程在addWorker中调用t.start()方法后就启动了线程。而Worker的run中又调用了ThreadPoolExecutor的runWorker方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    runWorker(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="ThreadPoolExecutor-runWorker-Worker-worker"><a href="#ThreadPoolExecutor-runWorker-Worker-worker" class="headerlink" title="ThreadPoolExecutor.runWorker(Worker worker)"></a>ThreadPoolExecutor.runWorker(Worker worker)</h4><p>  runWorker是线程池中线程运行的核心，通过一个while的loop循环来保证线程运行状态，首先会处理初始化Worker的任务，如果初始化任务为空则会从任务队列中获取任务进行执行。</p>
<ul>
<li>获取需要执行的任务，初始化任务或者从任务队列中获取的任务</li>
<li>检查线程池状态，保证线程池能够及时中断</li>
<li>beforeExecute—&gt;task.run()—&gt;afterExecute</li>
<li>退出while循环后，执行processWorkerExit方法，中断一个空闲线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</div><div class="line">   	Thread wt = Thread.currentThread();</div><div class="line">    Runnable task = w.firstTask;    <span class="comment">//先执行初始化时的任务</span></div><div class="line">    w.firstTask = <span class="keyword">null</span>;</div><div class="line">    w.unlock(); <span class="comment">// allow interrupts</span></div><div class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">//主要用来判断线程是正常结束还是异常结束，true为异常结束，在processWorkerExit中用来标志是否将线程池中的线程数减一</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</div><div class="line">            w.lock();</div><div class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></div><div class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></div><div class="line">            <span class="comment">// requires a recheck in second case to deal with</span></div><div class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></div><div class="line">          	<span class="comment">//判断线程池状态，中断线程</span></div><div class="line">          	<span class="comment">// 线程池状态&gt;=STOP并且线程未被中断，需要中断线程</span></div><div class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</div><div class="line">                 (Thread.interrupted() &amp;&amp;</div><div class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</div><div class="line">                !wt.isInterrupted())</div><div class="line">                wt.interrupt();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              	<span class="comment">//执行自定义的任务执行前操作，默认什么也不执行</span></div><div class="line">                beforeExecute(wt, task);</div><div class="line">                Throwable thrown = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                  	<span class="comment">//执行任务</span></div><div class="line">                    task.run();</div><div class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> x;</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</div><div class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                  	<span class="comment">//任务执行后执行的操作，默认什么也不执行</span></div><div class="line">                    afterExecute(task, thrown);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                task = <span class="keyword">null</span>;</div><div class="line">                w.completedTasks++;</div><div class="line">                w.unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        completedAbruptly = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      	<span class="comment">//线程退出后执行清理工作</span></div><div class="line">        processWorkerExit(w, completedAbruptly);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask()"></a>getTask()</h4><p>  getTask主要有两个个功能，获取任务队列中的任务并判断是否需要回收线程(返回null则说明需要回收线程)。</p>
<ul>
<li>例行检查线程池状态</li>
<li>根据timed(是否需要回收线程)和timeOut(线程空闲时间是否超过keepAlive)等来判断是否回收线程</li>
<li>如果需要回收线程，则利用任务队列的poll机制来设定线程空闲时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回null则退出线程</span></div><div class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">int</span> c = ctl.get();</div><div class="line">        <span class="keyword">int</span> rs = runStateOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// Check if queue empty only if necessary.</span></div><div class="line">      	<span class="comment">// 1. rs &gt; SHUTDOWN：线程池关闭，回收该线程</span></div><div class="line">      	<span class="comment">// 2. rs = SHUTDOWN &amp;&amp; workQueue.isEmpty():任务队列中任务执行完毕，回收该线程</span></div><div class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</div><div class="line">            decrementWorkerCount();</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</div><div class="line"></div><div class="line">        <span class="comment">// timed表示是否需要回收该线程，如果allowCoreThreadTimeOut设置为true则无论当前线程数</span></div><div class="line">        <span class="comment">// 设置多少都需要回收，否则只有当线程池中线程数大于corePoolSize时才需要回收</span></div><div class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</div><div class="line"></div><div class="line">        <span class="comment">//需要回收线程时，则将线程数减一，并返回null，在runWorker中回收线程</span></div><div class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</div><div class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</div><div class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">            <span class="comment">//1：如果timed为true，该线程需要回收，通过将workQueue.poll的超时时间设置为</span></div><div class="line">            <span class="comment">// keepAliveTime来保证返回的task是否为空，从而来判断该线程是否需要回收</span></div><div class="line">            <span class="comment">// 2：timed为false，则阻塞获取workQueue，直到线程中断或者获取到任务</span></div><div class="line">            Runnable r = timed ?</div><div class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</div><div class="line">                workQueue.take();</div><div class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> r;</div><div class="line">            timedOut = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</div><div class="line">            timedOut = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="processWorkerExit"><a href="#processWorkerExit" class="headerlink" title="processWorkerExit"></a>processWorkerExit</h4><p>  processWorkerExit主要是在线程结束后做一些处理工作</p>
<ul>
<li>如果线程异常结束则原子递减线程池中的线程数，同时移除线程池中的线程</li>
<li>尝试中断线程池，主要是进行例行检查</li>
<li>检查线程池状态，并根据线程池配置或者当前线程是否是正常结束来判断是否回补线程</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span> (completedAbruptly) <span class="comment">// 如果线程时异常退出，需要将线程数减一，正常线程数递减是在getTask()中进行的</span></div><div class="line">        decrementWorkerCount();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</div><div class="line">    mainLock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        completedTaskCount += w.completedTasks;</div><div class="line">        workers.remove(w);  <span class="comment">//移除线程</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        mainLock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tryTerminate();     <span class="comment">//尝试中断线程池，在执行过程中shutDown()或者shutDownNow()可能被调用</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> c = ctl.get();</div><div class="line"></div><div class="line">    <span class="comment">//线程处于RUNNINg和SHUTDOWN状态时，需要进一步处理线程</span></div><div class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//线程正常结束</span></div><div class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</div><div class="line">            <span class="comment">//如果允许核心线程回收，那么min就位0，否则为核心线程数</span></div><div class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</div><div class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</div><div class="line">                min = <span class="number">1</span>;</div><div class="line">            <span class="comment">//当前线程池线程数大于min则没有什么问题</span></div><div class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</div><div class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></div><div class="line">        &#125;</div><div class="line">        <span class="comment">//线程异常结束,需要回补该异常结束的线程</span></div><div class="line">        <span class="comment">//线程数为0但线程池处于SHUTDOWN状态或者非核心线程也被回收了，则需要创建一个线程执行任务队列中的任务</span></div><div class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CopyOnWriteArrayList源码分析]]></title>
      <url>/2017/08/08/CopyOnWriteArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><pre><code>CopyOnWriteArrayList是一个在多线程操作中线程安全的ArrayList的一个变种，她在所有对ArrayList对象的编辑操作(add,set等)都会复制一份副本，因此无论是对ArrayList操作还是对其iterator操作都不会抛ConcurrentModificationException异常。
</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>　　CopyOnWriteArrayList通常适用于读多写少的场景，对每次写操作都会复制一份数据的副本，因此不会影响原先数据的读操作。虽然每次复制副本会耗费时间，但相对于使用synchronize来保证线程安全，在特定场景下效果还是不错的。</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre><code>/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;

/**
 * Gets the array.  Non-private so as to also be accessible
 * from CopyOnWriteArraySet class.
 */
final Object[] getArray() {
    return array;
}

/**
 * Sets the array.
 */
final void setArray(Object[] a) {
    array = a;
}
</code></pre><p>　　CopyOnWriteArrayList维护一个ReentrantLock锁，主要用于保证同一时间只能有一个线程对array数据进行复制编辑操作(set,add等)，避免多线程下对数据复制操作造成数据不一致现象。 同时array声明为volatile，保证线程读取数据时将内存的数据刷新至缓存，从而得到最新数据。写入数据时保证最新数据写入到内存。在CopyOnWriteArrayList所有操作中，获取数据和写入数据不是直接使用this.array=array，而是使用getArray()和setArray()操作，刷新一下缓存，保证获得的是最新数据及将最新数据写入内存。</p>
<pre><code>@SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}

/**
 * {@inheritDoc}
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E get(int index) {
    return get(getArray(), index);
}
</code></pre><p>　　CopyOnWriteArrayList所有的读操作都是线程安全的，因为每次读操作读的都是元数据的一个snapshot。同时由getArray()来保证读到的数据都是最新版本的。</p>
<pre><code>/**
 * Appends the specified element to the end of this list.
 *
 * @param e element to be appended to this list
 * @return {@code true} (as specified by {@link Collection#add})
 */
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

/**
 * Removes the element at the specified position in this list.
 * Shifts any subsequent elements to the left (subtracts one from their
 * indices).  Returns the element that was removed from the list.
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 */
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre><p>　　再看一下编辑操作,这里以add()和remove()为例，可以看到每次只能有一个线程可以对ArrayList进行修改，而在修改之前通过getArray()来保证获取最新的array数据，然后复制一份array的副本newElements(复制过程根据具体操作而定,例如add会全部复制并预留一个位置，而remove则部分复制)，对副本进行编辑后再通过setArray将最新的副本赋给array。这样其他线程再进行读操作时通过getArray()获取的就是最近编辑过的数据。</p>
<h3 id="COWIterator"><a href="#COWIterator" class="headerlink" title="COWIterator"></a>COWIterator</h3><p>　　传统的ListIterator在遍历列表时如果列表被修改会有fast-fail机制来保证线程安全，而于CopyOnWriteArrayList已经具备线程安全性，并且CopyOnWriteArrayList的Iterator更多的用于数据的遍历，所以其关闭了iterator对数据的编辑功能.</p>
<p>/**</p>
<pre><code>     * Not supported. Always throws UnsupportedOperationException.
     * @throws UnsupportedOperationException always; {@code remove}
     *         is not supported by this iterator.
     */
    public void remove() {
        throw new UnsupportedOperationException();
    }


/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code set}
 *         is not supported by this iterator.
 */
public void set(E e) {
    throw new UnsupportedOperationException();
}

/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code add}
 *         is not supported by this iterator.
 */
public void add(E e) {
    throw new UnsupportedOperationException();
}
</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  CopyOnWriteArrayList通过编辑操作复制元数据副本的方式成功避免了多线程操作List线程不安全的问题，同时通过声明array[]为volitile类型保证线程每次读取的数据都是最新数据。<br>  由于每次编辑操作都会复制一份副本，因此CopyOnWriteArrayList只适用于读多改少的场景，在其他场景中还是建议使用synchronize或者Collections.SynchronizedList来保证线程安全<br>  CopyOnWriteArrayList不能保证线程遍历的数据一定是最新的数据，因此是能适用于实时性要求不高的场景。</p>
]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[String源码分析]]></title>
      <url>/2017/08/08/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<p>  String类内部维护了一个char[]类型的value用来存储字符串，相对来说源码较为简单些。</p>
<h3 id="1-不可变性"><a href="#1-不可变性" class="headerlink" title="1.不可变性"></a>1.不可变性</h3><p>String的不可变主要体现在三个方面:</p>
<ul>
<li>String类被定义为final类型，不可被继承</li>
<li>String中的value[]被定义为final</li>
<li>String中的所有生成新的String的操作底层都调用Array.copy或者System.copy来生成一个新的String对象</li>
</ul>
<h3 id="2-构造函数"><a href="#2-构造函数" class="headerlink" title="2.构造函数"></a>2.构造函数</h3><p>  String的有多个构造函数，但以下几个较为特殊</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = original.value;</div><div class="line">    <span class="keyword">this</span>.hash = original.hash;</div><div class="line">&#125;</div><div class="line"></div><div class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</div><div class="line">    <span class="comment">// assert share : "unshared not supported";</span></div><div class="line">    <span class="keyword">this</span>.value = value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  以上两个是较为特殊的一类构造函数，第一个用一个现成的String来初始化一个新的String对象，构造方法直接将新的String对象的value指向老的value对象。由于String是不可变的，所以这里不需要重新copy一份value的对象。第二个构造方法看似会破坏String类型的不可变性(当参数value变化时String也会变化)，但该构造方法并没有声明为public，只允许在包内使用，被声明为public的String(char value[])底层调用的是Array.copy来实现底层数据拷贝的，上述的两个构造函数已经不建议使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></div><div class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上面这个构造函数较为典型，很多其他的构造函数都与其类似或者底层调用了该构造函数，入参是一个char数组(byte[])，offset偏移位置及count偏移量。底层调用Arrays.copy函数来进行深度复制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</div><div class="line">    <span class="keyword">synchronized</span>(buffer) &#123;  <span class="comment">//保证线程安全</span></div><div class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  上述两个构造函数入参分别是StringBuffer和StringBuilder，底层都是调用Arrays.copyOf，唯一不同的是StringBuffer是线程不安全的，所有调用时需要用synchronized关键字。</p>
<h3 id="3-其他方法"><a href="#3-其他方法" class="headerlink" title="3.其他方法"></a>3.其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> fromIndex)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt;= sourceCount) &#123;</div><div class="line">        <span class="keyword">return</span> (targetCount == <span class="number">0</span> ? sourceCount : -<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        fromIndex = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">char</span> first = target[targetOffset];</div><div class="line">    <span class="keyword">int</span> max = sourceOffset + (sourceCount - targetCount);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sourceOffset + fromIndex; i &lt;= max; i++) &#123;</div><div class="line">        <span class="comment">/* Look for first character. */</span></div><div class="line">        <span class="keyword">if</span> (source[i] != first) &#123;</div><div class="line">            <span class="keyword">while</span> (++i &lt;= max &amp;&amp; source[i] != first);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Found first character, now look at the rest of v2 */</span></div><div class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</div><div class="line">            <span class="keyword">int</span> j = i + <span class="number">1</span>;</div><div class="line">            <span class="keyword">int</span> end = j + targetCount - <span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = targetOffset + <span class="number">1</span>; j &lt; end &amp;&amp; source[j]</div><div class="line">                    == target[k]; j++, k++);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (j == end) &#123;</div><div class="line">                <span class="comment">/* Found whole string. */</span></div><div class="line">                <span class="keyword">return</span> i - sourceOffset;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">char</span>[] source, <span class="keyword">int</span> sourceOffset, <span class="keyword">int</span> sourceCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">char</span>[] target, <span class="keyword">int</span> targetOffset, <span class="keyword">int</span> targetCount,</span></span></div><div class="line"><span class="function"><span class="params">        <span class="keyword">int</span> fromIndex)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Check arguments; return immediately where possible. For</span></div><div class="line"><span class="comment">     * consistency, don't check for null str.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> rightIndex = sourceCount - targetCount;</div><div class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fromIndex &gt; rightIndex) &#123;</div><div class="line">        fromIndex = rightIndex;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/* Empty string always matches. */</span></div><div class="line">    <span class="keyword">if</span> (targetCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> fromIndex;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> strLastIndex = targetOffset + targetCount - <span class="number">1</span>;</div><div class="line">    <span class="keyword">char</span> strLastChar = target[strLastIndex];</div><div class="line">    <span class="keyword">int</span> min = sourceOffset + targetCount - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> i = min + fromIndex;</div><div class="line"></div><div class="line">    startSearchForLastChar:</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        <span class="keyword">while</span> (i &gt;= min &amp;&amp; source[i] != strLastChar) &#123;</div><div class="line">            i--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (i &lt; min) &#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> start = j - (targetCount - <span class="number">1</span>);</div><div class="line">        <span class="keyword">int</span> k = strLastIndex - <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (j &gt; start) &#123;</div><div class="line">            <span class="keyword">if</span> (source[j--] != target[k--]) &#123;</div><div class="line">                i--;</div><div class="line">                <span class="keyword">continue</span> startSearchForLastChar;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> start - sourceOffset + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  indexOf和lastIndexOf主要是index和lastIndex函数的底层调用，通读代码会发现底层实现并没有特别牛逼的kmp算法，仍然是一个字符一个字符扫描实现的。其中lastIndexOf还是用了continue startSearchForLastChar;相对来说比较少见。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</div><div class="line">        <span class="keyword">int</span> len = value.length;</div><div class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">char</span>[] val = value; <span class="comment">/* avoid getfield opcode */</span></div><div class="line"></div><div class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</div><div class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果找不到则返回this</span></div><div class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</div><div class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</div><div class="line">                buf[j] = val[j];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</div><div class="line">                <span class="keyword">char</span> c = val[i]; <span class="comment">//替换</span></div><div class="line">                buf[i] = (c == oldChar) ? newChar : c;</div><div class="line">                i++;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//返回新的String,利用上述包内的非public构造函数</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  replace用于将String对象中的一个字符替换为另一个字符，如果找不到制定的字符则返回本身，如果找到则会另建一个新的String对象返回。</p>
]]></content>
      
        <categories>
            
            <category> Java源码分析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java源码 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>/2017/08/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
    </entry>
    
  
  
</search>
